<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoMDB - Matriz de Decisi칩n Interactiva v2</title>
    <style>
        :root {
            --color-primary: #00ED64;
            --color-primary-light: rgba(0, 237, 100, 0.1);
            --color-accent: #5644D4;
            --color-bg-primary: #001124;
            --color-bg-secondary: #0D2A3D;
            --color-bg-tertiary: #112331;
            --color-bg-card: rgba(13, 42, 61, 0.5);
            --color-text-primary: #FFFFFF;
            --color-text-secondary: #B8C5D6;
            --color-text-dark: #001124;
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --spacing-2xl: 3rem;
            --spacing-3xl: 4rem;
            --radius-sm: 0.25rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
            --radius-full: 9999px;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            --text-3xl: 1.875rem;
            --transition-base: all 0.3s ease;
            --transition-slow: all 0.5s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--color-bg-primary);
            color: var(--color-text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .hero {
            min-height: 100vh;
            position: relative;
            padding: var(--spacing-2xl) var(--spacing-lg);
        }

        .hero-background {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
            z-index: -2;
        }

        .hero-blur {
            position: fixed;
            width: 400px;
            height: 400px;
            border-radius: 50%;
            filter: blur(100px);
            opacity: 0.3;
            z-index: -1;
        }

        .hero-blur-primary {
            background: var(--color-primary);
            top: 10%;
            right: 10%;
            animation: float 20s ease-in-out infinite;
        }

        .hero-blur-accent {
            background: var(--color-accent);
            bottom: 10%;
            left: 10%;
            animation: float 20s ease-in-out infinite reverse;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0); }
            33% { transform: translate(30px, -30px); }
            66% { transform: translate(-20px, 20px); }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-md);
            border-radius: var(--radius-full);
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge-primary {
            background: var(--color-primary-light);
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
        }

        .badge-secondary {
            background: rgba(86, 68, 212, 0.1);
            color: var(--color-accent);
            border: 1px solid var(--color-accent);
        }

        .text-gradient {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: var(--spacing-lg);
        }

        .card {
            background: var(--color-bg-card);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            backdrop-filter: blur(10px);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-md) var(--spacing-xl);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-lg);
            background: transparent;
            color: var(--color-primary);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-base);
            text-decoration: none;
            font-size: var(--text-base);
        }

        .btn:hover {
            background: var(--color-primary);
            color: var(--color-text-dark);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 237, 100, 0.3);
        }

        .animate-fadeIn {
            animation: fadeIn 0.5s ease-out;
        }

        .animate-slideInLeft {
            animation: slideInLeft 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        .mb-3 { margin-bottom: var(--spacing-md); }
        .mb-4 { margin-bottom: var(--spacing-lg); }
        .mb-5 { margin-bottom: var(--spacing-xl); }
        .mt-3 { margin-top: var(--spacing-md); }
        .mt-4 { margin-top: var(--spacing-lg); }
        .text-center { text-align: center; }

        .question-card {
            background: linear-gradient(135deg, var(--color-bg-secondary) 0%, rgba(13, 42, 61, 0.8) 100%);
            border: 1px solid rgba(0, 237, 100, 0.2);
            margin-bottom: var(--spacing-lg);
            transition: all var(--transition-base);
        }

        .question-card:hover {
            border-color: var(--color-primary);
            box-shadow: 0 0 20px rgba(0, 237, 100, 0.2);
        }

        .question-text {
            color: var(--color-text-primary);
            font-size: var(--text-lg);
            margin-bottom: var(--spacing-lg);
            line-height: 1.6;
        }

        .response-buttons {
            display: flex;
            gap: var(--spacing-md);
        }

        .response-btn {
            flex: 1;
            padding: var(--spacing-md) var(--spacing-lg);
            border: 2px solid transparent;
            border-radius: var(--radius-lg);
            background: rgba(255, 255, 255, 0.05);
            color: var(--color-text-secondary);
            cursor: pointer;
            transition: all var(--transition-base);
            font-weight: 600;
        }

        .response-btn:hover {
            background: rgba(0, 237, 100, 0.1);
            border-color: var(--color-primary);
            color: var(--color-text-primary);
        }

        .response-btn.selected {
            background: var(--color-primary);
            color: var(--color-text-dark);
            border-color: var(--color-primary);
        }

        .results-section {
            margin-top: var(--spacing-3xl);
            padding: var(--spacing-xl);
            background: linear-gradient(135deg, var(--color-bg-card) 0%, rgba(86, 68, 212, 0.1) 100%);
            border-radius: var(--radius-xl);
            border: 1px solid rgba(0, 237, 100, 0.2);
        }

        .database-score {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
            background: var(--color-bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all var(--transition-base);
        }

        .database-score:hover {
            transform: translateX(4px);
            border-color: var(--color-primary);
        }

        .database-name {
            font-size: var(--text-xl);
            font-weight: 700;
            color: var(--color-text-primary);
        }

        .score-container {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .score-bar {
            width: 200px;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-full);
            overflow: hidden;
            position: relative;
        }

        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary) 0%, var(--color-accent) 100%);
            border-radius: var(--radius-full);
            transition: width var(--transition-slow);
            position: relative;
        }

        .score-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .score-value {
            font-size: var(--text-2xl);
            font-weight: 700;
            color: var(--color-primary);
            min-width: 60px;
            text-align: center;
        }

        .progress-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: var(--spacing-xl);
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .progress-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all var(--transition-base);
        }

        .progress-dot.completed {
            background: var(--color-primary);
            box-shadow: 0 0 10px rgba(0, 237, 100, 0.5);
        }

        .progress-dot.current {
            background: var(--color-accent);
            animation: pulse 2s ease-in-out infinite;
        }

        .recommendation {
            background: linear-gradient(135deg, var(--color-primary-light) 0%, rgba(86, 68, 212, 0.1) 100%);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            margin-top: var(--spacing-xl);
            text-align: center;
        }

        .recommendation h3 {
            color: var(--color-primary);
            margin-bottom: var(--spacing-md);
        }

        .reset-btn {
            margin-top: var(--spacing-xl);
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid #EF4444;
            color: #EF4444;
        }

        .reset-btn:hover {
            background: #EF4444;
            color: white;
        }

        .header-section {
            text-align: center;
            margin-bottom: var(--spacing-3xl);
        }

        .subtitle {
            font-size: var(--text-xl);
            color: var(--color-text-secondary);
            margin-bottom: var(--spacing-xl);
        }

        .technical-justification {
            margin-top: var(--spacing-3xl);
            background: linear-gradient(135deg, var(--color-bg-tertiary) 0%, rgba(17, 35, 49, 0.8) 100%);
            border: 1px solid rgba(86, 68, 212, 0.3);
            border-radius: var(--radius-xl);
            padding: var(--spacing-2xl);
        }

        .justification-question {
            background: var(--color-bg-secondary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            border-left: 4px solid var(--color-primary);
        }

        .question-title {
            color: var(--color-primary);
            font-size: var(--text-lg);
            font-weight: 700;
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .user-response {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-md);
            border-radius: var(--radius-full);
            font-weight: 600;
            font-size: var(--text-sm);
            margin-left: var(--spacing-md);
        }

        .user-response.yes {
            background: rgba(0, 237, 100, 0.2);
            color: var(--color-primary);
        }

        .user-response.no {
            background: rgba(239, 68, 68, 0.2);
            color: #EF4444;
        }

        .justification-content {
            color: var(--color-text-secondary);
            line-height: 1.6;
        }

        .tech-score {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-md);
            font-weight: 600;
            font-size: var(--text-sm);
            margin: 0 var(--spacing-xs);
        }

        .tech-score.score-1 {
            background: rgba(0, 237, 100, 0.2);
            color: var(--color-primary);
        }

        .tech-score.score-0 {
            background: rgba(239, 68, 68, 0.2);
            color: #EF4444;
        }

        .tech-explanation {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-md);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            border-left: 3px solid var(--color-accent);
        }

        .toggle-justification {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-primary) 100%);
            margin-top: var(--spacing-xl);
        }

        .toggle-justification:hover {
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(86, 68, 212, 0.4);
        }

        .database-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 8px;
            font-weight: 600;
        }

        .badge-mongodb { background: #13AA52; color: white; }
        .badge-aws { background: #FF9900; color: white; }
        .badge-google { background: #4285F4; color: white; }
        .badge-opensource { background: #6B7280; color: white; }
    </style>
</head>
<body>
    <section class="hero">
        <div class="hero-background"></div>
        <div class="hero-blur hero-blur-primary"></div>
        <div class="hero-blur hero-blur-accent"></div>
        
        <div class="container">
            <div class="header-section">
                <div class="badge badge-primary mb-4">
                    <span>游꿢</span>
                    Arquitectura de Datos 2025
                </div>
                <h1 class="text-gradient">Matriz de Decisi칩n Interactiva v2.0</h1>
                <p class="subtitle">
                    Eval칰a 9 tecnolog칤as de bases de datos l칤deres del mercado<br>
                    respondiendo 19 preguntas estrat칠gicas para encontrar la soluci칩n perfecta
                </p>
                <div style="margin-top: 20px; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <span class="badge badge-secondary">MongoDB</span>
                    <span class="badge badge-secondary">PostgreSQL</span>
                    <span class="badge badge-secondary">DynamoDB</span>
                    <span class="badge badge-secondary">BigQuery</span>
                    <span class="badge badge-secondary">Firestore</span>
                    <span class="badge badge-secondary">Bigtable</span>
                    <span class="badge badge-secondary">AlloyDB</span>
                    <span class="badge badge-secondary">YugabyteDB</span>
                    <span class="badge badge-secondary">Redis</span>
                </div>
            </div>

            <div class="progress-indicator" id="progressIndicator"></div>
            <div id="questionsContainer"></div>

            <div class="results-section" id="resultsSection">
                <h2 class="text-center mb-4">游늵 Resultados en Tiempo Real</h2>
                <div id="scoresContainer"></div>
                <div id="recommendationContainer"></div>
                <div class="text-center" id="resetButtonContainer" style="display: none;">
                    <button class="btn toggle-justification" onclick="toggleJustification()" id="justificationBtn">
                        游늶 Ver Justificaci칩n T칠cnica Detallada
                    </button>
                    <button class="btn reset-btn" onclick="resetMatrix()">
                        游댃 Realizar Nueva Evaluaci칩n
                    </button>
                </div>
            </div>

            <div class="technical-justification" id="technicalJustification" style="display: none;">
                <h2 class="text-center mb-4">游댧 Justificaci칩n T칠cnica Detallada</h2>
                <p class="text-center mb-5" style="color: var(--color-text-secondary);">
                    An치lisis arquitect칩nico caso por caso de cada tecnolog칤a de base de datos
                </p>
                <div id="justificationContent"></div>
            </div>
        </div>
    </section>
    <script>
        const questions = [
            "쯅ecesita realizar consultas complejas (joins, subqueries, etc.)?",
            "Requiere una soluci칩n basada en protocolo abierto para evitar vendor lock-in?",
            "쯅ecesita soporte de transacciones ACID complejas (m칰ltiples registros)?",
            "Requiere m칤nimo impacto/overhead de operaciones (Serverless/Full Managed)?",
            "쯃a base de datos ser치 utilizada para anal칤tica sobre grandes vol칰menes de datos estructurados (Data Warehouse)?",
            "Requiere realizar consultas geoespaciales avanzadas?",
            "쯃as operaciones con datos de tipo fecha (Time-Series) son muy frecuentes?",
            "쯅ecesita alta disponibilidad de escritura nativa multi-regi칩n (Activo-Activo)?",
            "Requiere un modelo de datos enriquecido (Documentos, JSON nativo)?",
            "쯃a base de datos ser치 usada para cargas de trabajo poco frecuentes (modelo Serverless real, pago por uso)?",
            "쯅ecesita un modelo de datos nativo de Grafos?",
            "Requiere validaci칩n estricta y forzada de esquema?",
            "쯅ecesita paginaci칩n tradicional eficiente con conteo total (COUNT(*))?",
            "쮼l uso principal ser치 como cach칠 en memoria de ultra baja latencia?",
            "쯅ecesita operaciones simples de clave-valor (Key-Value) a escala masiva?",
            "쮼l caso de uso principal es Business Intelligence (BI) interactivo o ejecuci칩n de modelos ML con SQL?",
            "쯃a aplicaci칩n requiere sincronizaci칩n en tiempo real con clientes web/m칩viles y soporte offline?",
            "Requiere rendimiento OLTP superior a PostgreSQL est치ndar pero con 100% compatibilidad?",
            "쯅ecesita ingerir flujos de datos masivos (millones ops/seg) para IoT, Ad-Tech o perfiles en tiempo real?"
        ];

        const databases = {
            'MongoDB':           [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0],
            'PostgreSQL':        [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
            'Redis':             [0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            'DynamoDB':          [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            'Google BigQuery':   [1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0],
            'Google Firestore':  [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            'Google Bigtable':   [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            'Google AlloyDB':    [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0],
            'YugabyteDB':        [1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1]
        };

        const technicalJustifications = [
            // Primeras 5 justificaciones t칠cnicas completas
            {
                question: "쮺onsultas complejas? (joins, subqueries, etc.)",
                explanations: {
                    "MongoDB": "Con su Aggregation Pipeline es extremadamente potente y puede manejar consultas muy complejas de manera eficiente, incluyendo $lookup para joins y transformaciones multi-etapa.",
                    "PostgreSQL": "Las bases de datos relacionales son los reyes aqu칤. PostgreSQL maneja joins complejos, subqueries y agregaciones con optimizadores de consultas avanzados.",
                    "Redis": "Es un almac칠n clave-valor. Las consultas complejas van contra su arquitectura fundamental de simplicidad y velocidad.",
                    "DynamoDB": "No est치 dise침ada para esto. Su modelo de acceso se basa en claves primarias. Realizar 'joins' es ineficiente o imposible.",
                    "Google BigQuery": "Utiliza SQL est치ndar y est치 pensado para an치lisis complejo de grandes datasets con joins, subconsultas y funciones anal칤ticas avanzadas.",
                    "Google Firestore": "Ofrece consultas sencillas basadas en propiedades. No soporta joins entre colecciones ni subconsultas multi-documento.",
                    "Google Bigtable": "No admite joins ni SQL. Sus accesos son mediante row keys y rangos, sin lenguaje de consultas declarativo.",
                    "Google AlloyDB": "Compatible con PostgreSQL, soporta todo el repertorio SQL complejo con optimizaciones adicionales de Google para mejor rendimiento.",
                    "YugabyteDB": "Mediante su interfaz YSQL compatible con PostgreSQL, soporta plenamente joins y consultas SQL complejas en un entorno distribuido."
                }
            },
            {
                question: "쯇rotocolo abierto / Evitar Lock-in?",
                explanations: {
                    "MongoDB": "Basado en motor open source con protocolo abierto BSON. La migraci칩n entre diferentes proveedores es factible.",
                    "PostgreSQL": "Motor de c칩digo abierto reconocido mundialmente. Puedes migrar a otro proveedor cloud o on-premise con esfuerzo relativamente bajo.",
                    "Redis": "Open source con protocolo completamente abierto. M치xima portabilidad entre diferentes implementaciones.",
                    "DynamoDB": "Completamente propietario de AWS con API 칰nica. Alto lock-in con pocas alternativas compatibles.",
                    "Google BigQuery": "Servicio 100% propietario de Google Cloud. No existe versi칩n open source para migrar.",
                    "Google Firestore": "Servicio cerrado de Google sin motor open source equivalente. Alto vendor lock-in.",
                    "Google Bigtable": "Servicio propietario, aunque parcialmente compatible con HBase. Dependencia fuerte de GCP.",
                    "Google AlloyDB": "Basado en PostgreSQL pero con optimizaciones propietarias de Google. Portabilidad parcial.",
                    "YugabyteDB": "Open source (Apache 2.0) desplegable en cualquier infraestructura con APIs PostgreSQL y Cassandra compatibles."
                }
            },
            {
                question: "쯊ransacciones ACID complejas (m칰ltiples registros)?",
                explanations: {
                    "MongoDB": "Soporta transacciones ACID multi-documento desde v4.0, permitiendo agrupar operaciones en m칰ltiples colecciones con atomicidad completa.",
                    "PostgreSQL": "Referente en transacciones ACID. Soporta transacciones multi-fila, multi-tabla con atomicidad completa y aislamiento configurable.",
                    "Redis": "MULTI/EXEC agrupa operaciones pero sin aislamiento robusto ni durabilidad ACID completa. No es para transacciones complejas.",
                    "DynamoDB": "Transacciones limitadas a 100 operaciones y 4MB. No tan flexible como SQL tradicional pero funcional para casos b치sicos.",
                    "Google BigQuery": "No es transaccional. Es append-only para an치lisis, no para transacciones OLTP.",
                    "Google Firestore": "Soporta transacciones hasta 500 documentos con aislamiento serializable, pero con restricciones de tiempo (60s) y tama침o (10MB).",
                    "Google Bigtable": "Solo garantiza atomicidad a nivel de fila individual, no transacciones multi-fila.",
                    "Google AlloyDB": "Al ser PostgreSQL, soporta totalmente transacciones ACID complejas con durabilidad mejorada por su arquitectura.",
                    "YugabyteDB": "Dise침ado como SQL distribuido CP con transacciones distribuidas ACID usando Raft para consenso global."
                }
            },
            {
                question: "쯄칤nimo impacto operativo? (Serverless/Full Managed)",
                explanations: {
                    "MongoDB": "MongoDB Atlas ofrece opciones totalmente administradas incluyendo Atlas Serverless con escalado autom치tico y pago por uso.",
                    "PostgreSQL": "RDS requiere gestionar instancias, tama침o, almacenamiento y par치metros. No es serverless, requiere planificaci칩n de capacidad.",
                    "Redis": "Como servicio administrado (ElastiCache, Redis Cloud) libera de gesti칩n pero requiere nodos activos siempre corriendo.",
                    "DynamoDB": "Emblem치tica en serverless: no hay servidores que aprovisionar, escala autom치ticamente seg칰n demanda, pago por uso real.",
                    "Google BigQuery": "Totalmente serverless, no hay clusters que crear. Escala autom치ticamente sin intervenci칩n alguna.",
                    "Google Firestore": "Fully-managed y serverless. Escala autom치ticamente seg칰n tr치fico sin configuraci칩n de infraestructura.",
                    "Google Bigtable": "Requiere aprovisionar nodos manualmente y gestionar capacidad. No es serverless aunque sea gestionado.",
                    "Google AlloyDB": "Servicio gestionado pero requiere seleccionar instancias fijas. No tiene modo serverless actualmente.",
                    "YugabyteDB": "Requiere gestionar un cl칰ster de servidores. Incluso en Yugabyte Cloud necesitas definir topolog칤a."
                }
            },
            {
                question: "쮸nal칤tica / Data Warehouse?",
                explanations: {
                    "MongoDB": "Base operacional, no anal칤tica. Para an치lisis masivos necesitar칤as herramientas complementarias como MongoDB Charts o exportar a un warehouse.",
                    "PostgreSQL": "Usar una base transaccional como data warehouse es un anti-patr칩n. No escalar치 ni rendir치 para consultas anal칤ticas masivas.",
                    "Redis": "Cache en memoria. Usar como data warehouse ser칤a t칠cnicamente incorrecto y extremadamente costoso por la RAM requerida.",
                    "DynamoDB": "Almac칠n operacional clave-valor. No dise침ado para consultas anal칤ticas complejas cross-record. Exportar a S3+Athena para an치lisis.",
                    "Google BigQuery": "Herramienta dise침ada espec칤ficamente para esto. Data warehouse serverless con capacidad de petabytes y SQL est치ndar.",
                    "Google Firestore": "Base NoSQL operacional. Para anal칤tica se deben exportar datos a BigQuery, no es su prop칩sito.",
                    "Google Bigtable": "Puede almacenar petabytes pero no proporciona SQL ni agregaciones nativas. Requiere herramientas externas para an치lisis.",
                    "Google AlloyDB": "Tiene capacidades h칤bridas HTAP con motor columnar pero no reemplaza un data warehouse dedicado para petabytes.",
                    "YugabyteDB": "Orientado a OLTP distribuido, no a OLAP. Para anal칤tica masiva mejor usar un warehouse dedicado como BigQuery o Redshift."
                }
            },
            {
                question: "쮺onsultas geoespaciales avanzadas?",
                explanations: {
                    "MongoDB": "Soporte geoespacial nativo excelente con 칤ndices 2d/2dsphere y operadores como $near, $geoWithin, $geoIntersects. Ideal para aplicaciones con mapas.",
                    "PostgreSQL": "Con PostGIS es el est치ndar de oro en geodatos open source. Cientos de funciones para c치lculos avanzados, transformaciones de coordenadas y an치lisis GIS.",
                    "Redis": "Comandos geo b치sicos (GEORADIUS, GEOADD) para puntos y distancias simples. Limitado comparado con soluciones especializadas.",
                    "DynamoDB": "Sin soporte geoespacial nativo. Requiere implementaci칩n manual con geohashes como workaround, lo cual es complejo y limitado.",
                    "Google BigQuery": "BigQuery GIS permite operaciones geoespaciales en SQL sobre datasets masivos. Excelente para an치lisis geo pero no para queries en tiempo real.",
                    "Google Firestore": "Sin tipo geoespacial nativo. Debe usar t칠cnica de geohashes manualmente, no es una soluci칩n completa ni eficiente.",
                    "Google Bigtable": "No implementa funciones geoespaciales. Cualquier c치lculo geo requiere procesamiento externo en la aplicaci칩n.",
                    "Google AlloyDB": "Compatible con PostGIS al ser PostgreSQL, hereda todas las capacidades geoespaciales con optimizaciones adicionales de Google.",
                    "YugabyteDB": "Soporte parcial de PostGIS pero con limitaciones en entorno distribuido. Funciones b치sicas funcionan pero no todas las avanzadas."
                }
            },
            {
                question: "쯆peraciones frecuentes con fechas (Time-Series)?",
                explanations: {
                    "MongoDB": "Excelente para time-series con TTL indexes para expiraci칩n autom치tica y colecciones time-series optimizadas desde v5.0 con almacenamiento columnar interno.",
                    "PostgreSQL": "Con TimescaleDB (extensi칩n) se convierte en potente base para series temporales con particionado autom치tico y compresi칩n.",
                    "Redis": "Excelente para time-series en tiempo real con m칩dulo RedisTimeSeries. Ideal para m칠tricas recientes en memoria con downsampling.",
                    "DynamoDB": "Patr칩n com칰n para time-series usando composite keys (deviceId + timestamp). Escalabilidad masiva para ingesta de eventos IoT.",
                    "Google BigQuery": "Puede almacenar series hist칩ricas masivas para an치lisis pero no para ingesta en tiempo real punto a punto. Mejor para batch.",
                    "Google Firestore": "Limitaciones de throughput (1 escritura/seg por documento) lo hacen inadecuado para time-series de alta frecuencia.",
                    "Google Bigtable": "Particularmente bien adaptada para series de tiempo e IoT. Dise침o de row key con timestamp permite acceso eficiente a datos recientes.",
                    "Google AlloyDB": "Puede manejar series de tiempo como PostgreSQL con mejor rendimiento de I/O. Compatible con TimescaleDB en teor칤a.",
                    "YugabyteDB": "Soporta time-series distribuidas con particionado por rangos de tiempo. Buena opci칩n para series con requerimientos ACID."
                }
            },
            {
                question: "쮼scritura nativa multi-regi칩n (Activo-Activo)?",
                explanations: {
                    "MongoDB": "Global Clusters permite escrituras locales activas en m칰ltiples regiones con resoluci칩n de conflictos last-write-wins y zonas geogr치ficas.",
                    "PostgreSQL": "Requiere soluciones externas complejas como BDR. No es capacidad nativa out-of-the-box, propenso a conflictos.",
                    "Redis": "Solo master-slave tradicional en versi칩n open source. Multi-master requiere Redis Enterprise con CRDTs (soluci칩n comercial).",
                    "DynamoDB": "Global Tables ofrece verdadero activo-activo multi-regi칩n administrado autom치ticamente con resoluci칩n de conflictos integrada.",
                    "Google BigQuery": "Multi-regi칩n para disponibilidad pero no es transaccional activo-activo. Los datos se replican pero no hay escrituras concurrentes.",
                    "Google Firestore": "Multi-regi칩n autom치tica con consistencia fuerte global usando Spanner internamente. Escrituras desde cualquier regi칩n.",
                    "Google Bigtable": "Replicaci칩n entre cl칰steres multi-regi칩n con escrituras concurrentes y consistencia eventual. Configuraci칩n manual requerida.",
                    "Google AlloyDB": "Solo cl칰steres secundarios de lectura cross-region, no multi-master verdadero. Modelo activo-pasivo para DR.",
                    "YugabyteDB": "Dise침ado para distribuci칩n geogr치fica con consenso Raft. Escrituras desde cualquier regi칩n con consistencia configurable."
                }
            },
            {
                question: "쯄odelo de datos enriquecido (Documentos, JSON nativo)?",
                explanations: {
                    "MongoDB": "L칤der indiscutible en documentos. Base nativa BSON con esquemas flexibles, subdocumentos, arrays y consultas ricas sobre JSON anidado.",
                    "PostgreSQL": "Soporte JSONB excelente. Permite almacenar, indexar (GIN) y consultar documentos JSON eficientemente con operadores y funciones.",
                    "Redis": "Almacena strings por defecto. Requiere m칩dulo RedisJSON para manejo real de documentos con path queries.",
                    "DynamoDB": "Soporta documentos JSON con estructuras anidadas (Maps, Lists) y operaciones por ruta. Modelo documento-clave-valor h칤brido.",
                    "Google BigQuery": "Soporta JSON y estructuras anidadas para an치lisis pero no es base documental transaccional. M치s para ETL que OLTP.",
                    "Google Firestore": "Base documental JSON nativa. Estructura flexible por documento con campos anidados, arrays y mapas. Similar a MongoDB.",
                    "Google Bigtable": "Almacena bytes en columnas, no tiene noci칩n de documentos JSON. Requerir칤a serializaci칩n manual.",
                    "Google AlloyDB": "Hereda soporte JSONB completo de PostgreSQL con las mismas capacidades de indexaci칩n y consulta.",
                    "YugabyteDB": "Compatible con JSONB de PostgreSQL en YSQL. Documentos JSON distribuidos con 칤ndices secundarios globales."
                }
            },
            {
                question: "쮺argas poco frecuentes (Serverless real)?",
                explanations: {
                    "MongoDB": "Atlas Serverless escala a cero y cobra solo por operaciones realizadas. Ideal para prototipos y aplicaciones intermitentes.",
                    "PostgreSQL": "RDS factura por hora est칠 activa o no. No hay modo serverless real, siempre pagas por capacidad reservada.",
                    "Redis": "Requiere nodos activos continuamente. ElastiCache no escala a cero. Pagas 24/7 por la memoria reservada.",
                    "DynamoDB": "On-Demand mode perfecto para cargas espor치dicas. Pagas exactamente por cada operaci칩n, sin m칤nimos.",
                    "Google BigQuery": "Completamente on-demand, pagas por TB procesado solo cuando ejecutas consultas. Cero costo sin consultas.",
                    "Google Firestore": "Modelo pago por operaci칩n sin servidores que mantener. Perfecto para apps con tr치fico irregular.",
                    "Google Bigtable": "Requiere m칤nimo 1 nodo siempre activo por cl칰ster. No es serverless, pagas aunque no uses.",
                    "Google AlloyDB": "Instancias fijas sin modo serverless. Siempre incurres costo de instancia primaria encendida.",
                    "YugabyteDB": "Requiere cluster activo m칤nimo. No tiene escalado a cero autom치tico ni en Yugabyte Cloud."
                }
            },
            {
                question: "쯄odelo de Grafos nativo?",
                explanations: {
                    "MongoDB": "No es base de grafos. Modelar relaciones de grafos requerir칤a agregaciones complicadas con m칰ltiples $lookup, ineficiente para traversals.",
                    "PostgreSQL": "No es base de grafos. Consultas recursivas con WITH RECURSIVE ser칤an muy lentas para grafos complejos.",
                    "Redis": "Requiere m칩dulo RedisGraph separado (ahora deprecado). No es funcionalidad nativa del core.",
                    "DynamoDB": "Modelo clave-valor incompatible con traversals de grafos. Cada salto requerir칤a query separada, inadecuado.",
                    "Google BigQuery": "Puede procesar datos de grafos anal칤ticamente con SQL recursivo pero no para queries transaccionales de grafos.",
                    "Google Firestore": "Sin soporte de grafos. Cada relaci칩n requerir칤a query separada. No hay traversals ni algoritmos de grafos.",
                    "Google Bigtable": "No hay consultas de grafos. Modelo de filas/columnas inadecuado para relaciones complejas de grafos.",
                    "Google AlloyDB": "Sin modelo de grafos nativo. Solo esquema relacional tradicional que no optimiza para traversals.",
                    "YugabyteDB": "No es motor de grafos aunque puede modelar relaciones en tablas SQL. No optimizado para este caso."
                }
            },
            {
                question: "쯌alidaci칩n estricta de esquema?",
                explanations: {
                    "MongoDB": "Schema Validation opcional pero potente usando JSON Schema. Puede forzar estructura cuando se requiere manteniendo flexibilidad base.",
                    "PostgreSQL": "Validaci칩n estricta por definici칩n. Constraints, tipos de datos, foreign keys y reglas de integridad robustas enforced siempre.",
                    "Redis": "Sin noci칩n de esquema. Almacena bytes/strings arbitrarios. Toda validaci칩n recae en la aplicaci칩n.",
                    "DynamoDB": "Schema-less excepto keys. La validaci칩n de atributos recae completamente en la aplicaci칩n. No hay tipos enforced.",
                    "Google BigQuery": "Requiere definir esquema de tablas con tipos de datos enforced estrictamente. No permite datos fuera de esquema.",
                    "Google Firestore": "Schema-less por dise침o. Sin validaci칩n nativa de tipos. Puede usar Security Rules para validaci칩n b치sica.",
                    "Google Bigtable": "Sin esquema m치s all치 de column families. Valores son bytes sin tipo. No hay validaci칩n.",
                    "Google AlloyDB": "Igual que PostgreSQL: esquema fijo con tipos, constraints y validaci칩n estricta autom치tica.",
                    "YugabyteDB": "YSQL impone esquemas con tipos como PostgreSQL. YCQL tambi칠n define columnas con tipos est치ticos."
                }
            },
            {
                question: "쯇aginaci칩n tradicional con conteo total?",
                explanations: {
                    "MongoDB": "Soporta count() y skip()/limit() para paginaci칩n. Puede ser lento en colecciones muy grandes pero funcional.",
                    "PostgreSQL": "COUNT(*) y OFFSET/LIMIT optimizados por el query planner. Funciona bien para la mayor칤a de casos de paginaci칩n.",
                    "Redis": "No aplica concepto de paginaci칩n tradicional sobre m칰ltiples claves. Solo dentro de estructuras como sorted sets.",
                    "DynamoDB": "COUNT requiere Scan completo muy costoso. Usa paginaci칩n por tokens (LastEvaluatedKey), no offset tradicional.",
                    "Google BigQuery": "Soporta COUNT(*) y LIMIT/OFFSET pero costoso para paginaci칩n interactiva web. M치s para an치lisis batch.",
                    "Google Firestore": "Paginaci칩n por cursor con startAfter(). Ahora soporta count() agregaci칩n pero no offset arbitrario.",
                    "Google Bigtable": "Sin mecanismo de contar filas eficiente. Usa scanners con tokens de continuaci칩n, no paginaci칩n tradicional.",
                    "Google AlloyDB": "Igual que PostgreSQL con COUNT(*) y LIMIT/OFFSET est치ndar, posiblemente con optimizaciones adicionales.",
                    "YugabyteDB": "COUNT() distribuido y paginaci칩n SQL est치ndar. El count puede ser m치s lento por naturaleza distribuida."
                }
            },
            {
                question: "쯋so principal como cach칠 en memoria?",
                explanations: {
                    "MongoDB": "Base persistente en disco con cache interno. No dise침ada como cache primario, mejor usar Redis para eso.",
                    "PostgreSQL": "Base persistente en disco. Usarla como cach칠 ser칤a arquitect칩nicamente incorrecto, lento y costoso.",
                    "Redis": "Definici칩n misma de cach칠 en memoria. Latencia de microsegundos, estructuras de datos especializadas, TTL autom치tico.",
                    "DynamoDB": "Base persistente con latencia de milisegundos. Para cach칠 usar DAX encima. No es cache nativo.",
                    "Google BigQuery": "Data warehouse para an치lisis. Totalmente inapropiado para caching, latencias de segundos.",
                    "Google Firestore": "Base persistente NoSQL. No compite con caches in-memory, latencias de milisegundos vs microsegundos.",
                    "Google Bigtable": "Latencia de milisegundos para datos persistentes. No es cache, aunque r치pida para base persistente.",
                    "Google AlloyDB": "Base persistente ACID con durabilidad. No es vol치til ni optimizada para cache temporal.",
                    "YugabyteDB": "Base distribuida persistente con overhead de consenso. No es apropiada como cache layer."
                }
            },
            {
                question: "쯆peraciones clave-valor a escala masiva?",
                explanations: {
                    "MongoDB": "Puede hacer KV por _id eficientemente pero tiene m치s overhead que soluciones especializadas. No 칩ptimo para KV puro.",
                    "PostgreSQL": "Usar SQL para simple KV es como usar un cami칩n para entregar pizza. Funcionar치 pero es excesivo y no escala.",
                    "Redis": "Millones de ops/seg en memoria. Excepcional para key-value pero limitado por RAM disponible.",
                    "DynamoDB": "Dise침ada espec칤ficamente para esto. Escalabilidad casi ilimitada con latencia consistente de un d칤gito ms.",
                    "Google BigQuery": "No dise침ado para buscar registros individuales por clave. Requiere escanear, muy ineficiente.",
                    "Google Firestore": "Puede manejar KV pero m치s costoso que alternativas especializadas. Mejor para queries m치s complejas.",
                    "Google Bigtable": "Hecha para alto throughput key-value. Escala linealmente agregando nodos, millones ops/seg posibles.",
                    "Google AlloyDB": "Base relacional compleja. Demasiado overhead para simples operaciones KV. No es el caso de uso.",
                    "YugabyteDB": "YCQL (API Cassandra) excelente para key-value distribuido. Escala horizontalmente para KV masivo."
                }
            },
            {
                question: "쮹I interactivo o ML con SQL?",
                explanations: {
                    "MongoDB": "Se integra con herramientas BI v칤a conectores pero no ejecuta ML nativamente. MongoDB Charts para visualizaci칩n b치sica.",
                    "PostgreSQL": "Fuente para BI pero no optimizado para escaneo masivo anal칤tico. ML requiere extensiones externas como MADlib.",
                    "Redis": "No es herramienta anal칤tica ni de BI. Es un cache operacional, no para an치lisis de datos.",
                    "DynamoDB": "No es base anal칤tica. Los datos deben exportarse a S3 y analizarse con Athena o replicarse a Redshift.",
                    "Google BigQuery": "Dise침ado espec칤ficamente para esto. BigQuery ML permite crear y ejecutar modelos (regresi칩n, clustering, etc.) con SQL puro.",
                    "Google Firestore": "Base operacional para aplicaciones. Se exporta a BigQuery para cualquier an치lisis o BI.",
                    "Google Bigtable": "Almac칠n para servir datos a baja latencia, no para consultas BI complejas. Requiere herramientas externas.",
                    "Google AlloyDB": "A pesar del motor columnar secundario, no tiene ML integrado ni est치 optimizado para BI masivo como BigQuery.",
                    "YugabyteDB": "Base transaccional distribuida OLTP. No dise침ada para cargas BI masivas ni tiene capacidades ML."
                }
            },
            {
                question: "쯉incronizaci칩n tiempo real con clientes y offline?",
                explanations: {
                    "MongoDB": "Posible con Change Streams y Atlas Device Sync pero requiere configuraci칩n adicional. No tan integrado como Firestore.",
                    "PostgreSQL": "Requiere arquitectura compleja adicional con LISTEN/NOTIFY + websockets + cache cliente. No es nativo.",
                    "Redis": "PUB/SUB puede ser componente de arquitectura real-time pero no ofrece sincronizaci칩n de estado ni soporte offline.",
                    "DynamoDB": "Posible con DynamoDB Streams + AWS AppSync pero es arquitectura m치s compleja, no caracter칤stica nativa.",
                    "Google BigQuery": "Base anal칤tica batch, no para aplicaciones en tiempo real. No tiene concepto de listeners.",
                    "Google Firestore": "Raz칩n de ser principal. SDKs con listeners autom치ticos, actualizaciones real-time y cach칠 offline robusto integrado.",
                    "Google Bigtable": "No dise침ada para sincronizaci칩n con clientes finales. Es backend para servir datos, no para apps real-time.",
                    "Google AlloyDB": "Base relacional tradicional sin capacidades de sincronizaci칩n real-time o SDKs para clientes.",
                    "YugabyteDB": "Sin mecanismo nativo para sincronizaci칩n con clientes. Requerir칤a arquitectura adicional compleja."
                }
            },
            {
                question: "Rendimiento OLTP superior con compatibilidad PostgreSQL?",
                explanations: {
                    "MongoDB": "Alto rendimiento OLTP pero no es compatible con PostgreSQL. Usa su propio lenguaje de consultas.",
                    "PostgreSQL": "Es la l칤nea base de rendimiento. No puede ser superior a s칤 mismo. Escalado principalmente vertical.",
                    "Redis": "No es base relacional ni compatible con PostgreSQL. Es un cache key-value.",
                    "DynamoDB": "Alto rendimiento pero no es compatible con PostgreSQL ni SQL. API propietaria.",
                    "Google BigQuery": "No es base OLTP sino OLAP. Para an치lisis, no transacciones.",
                    "Google Firestore": "No es base relacional SQL. Es NoSQL documental con su propia API.",
                    "Google Bigtable": "No es base relacional. Alta performance pero no compatible con PostgreSQL.",
                    "Google AlloyDB": "Exactamente dise침ado para esto. PostgreSQL 100% compatible con 4x mejor rendimiento transaccional.",
                    "YugabyteDB": "SQL distribuido que escala OLTP horizontalmente manteniendo compatibilidad PostgreSQL. Performance superior via distribuci칩n."
                }
            },
            {
                question: "쯀ngesta masiva IoT/Ad-Tech (millones ops/seg)?",
                explanations: {
                    "MongoDB": "Escala bien pero 'millones ops/seg' apunta a h칤per-escala donde Bigtable/DynamoDB son m치s naturales.",
                    "PostgreSQL": "Una instancia no puede manejar millones ops/seg. Necesitar칤a sharding complejo manual.",
                    "Redis": "Muy r치pido pero limitaci칩n de memoria hace impr치ctica la ingesta persistente masiva. Mejor como cache.",
                    "DynamoDB": "Dise침ada para esto. Maneja millones ops/seg con auto-sharding y latencia consistente. Caso de uso perfecto.",
                    "Google BigQuery": "Streaming ingestion de alto throughput pero para an치lisis posterior, no para servir lecturas de baja latencia.",
                    "Google Firestore": "L칤mites de escritura (10k/seg inicialmente) muy por debajo de millones ops/seg. No es para este caso.",
                    "Google Bigtable": "Caso de uso can칩nico. Optimizada espec칤ficamente para ingesta masiva IoT/Ad-Tech con baja latencia a escala planetaria.",
                    "Google AlloyDB": "Base relacional no dise침ada para ingesta NoSQL masiva. Mejor para transacciones ACID complejas.",
                    "YugabyteDB": "Arquitectura distribuida permite escalar ingesta horizontalmente. Buena opci칩n para IoT con requerimientos ACID."
                }
            }
        ];

        const recommendations = {
            'MongoDB': 'Ideal para aplicaciones modernas con modelos de datos flexibles, consultas complejas y alta disponibilidad multi-regi칩n. Excelente balance entre funcionalidad y facilidad de uso.',
            'PostgreSQL': 'Excelente para aplicaciones que requieren consultas relacionales complejas, transacciones ACID robustas y funcionalidades geoespaciales con PostGIS.',
            'DynamoDB': 'Perfecto para aplicaciones serverless, operaciones key-value masivas y casos de uso con patrones de acceso predecibles. Escalabilidad pr치cticamente ilimitada.',
            'Redis': 'Perfecto para cach칠 en memoria, operaciones key-value de ultra baja latencia y casos de uso de alta velocidad. Ideal como complemento a otras bases de datos.',
            'Google BigQuery': '칍ptimo para an치lisis de datos masivos, data warehousing y Business Intelligence. 칔nico en su capacidad de ejecutar ML con SQL (BigQuery ML).',
            'Google Firestore': 'Ideal para aplicaciones web/m칩viles que necesitan sincronizaci칩n en tiempo real, soporte offline y escalado autom치tico sin gesti칩n de infraestructura.',
            'Google Bigtable': 'Excelente para ingesta masiva de datos IoT, Ad-Tech y series de tiempo. Maneja millones de operaciones por segundo con latencia consistente.',
            'Google AlloyDB': 'Perfecto cuando necesitas rendimiento PostgreSQL mejorado significativamente. Combina compatibilidad total con optimizaciones de Google.',
            'YugabyteDB': 'Ideal para aplicaciones que necesitan SQL distribuido globalmente con consistencia fuerte. Combina escalabilidad NoSQL con garant칤as ACID.'
        };

        let currentAnswers = [];
        let currentQuestionIndex = 0;

        function initializeMatrix() {
            createProgressIndicator();
            updateLiveResults();
            showQuestion(0);
        }

        function createProgressIndicator() {
            const container = document.getElementById('progressIndicator');
            container.innerHTML = '';
            
            for (let i = 0; i < questions.length; i++) {
                const dot = document.createElement('div');
                dot.className = 'progress-dot';
                if (i === 0) dot.classList.add('current');
                container.appendChild(dot);
            }
        }

        function updateProgressIndicator() {
            const dots = document.querySelectorAll('.progress-dot');
            dots.forEach((dot, index) => {
                dot.className = 'progress-dot';
                if (index < currentQuestionIndex) {
                    dot.classList.add('completed');
                } else if (index === currentQuestionIndex) {
                    dot.classList.add('current');
                }
            });
        }

        function showQuestion(index) {
            if (index >= questions.length) {
                const container = document.getElementById('questionsContainer');
                container.innerHTML = `
                    <div class="card question-card animate-fadeIn" style="text-align: center; background: linear-gradient(135deg, var(--color-primary-light) 0%, rgba(86, 68, 212, 0.1) 100%); border: 2px solid var(--color-primary);">
                        <h3 style="color: var(--color-primary); margin-bottom: var(--spacing-md);">
                            游꿀 춰Evaluaci칩n Completada!
                        </h3>
                        <p style="color: var(--color-text-secondary); font-size: var(--text-lg);">
                            Has respondido todas las preguntas. Revisa los resultados finales y la recomendaci칩n abajo.
                        </p>
                    </div>
                `;
                document.getElementById('resetButtonContainer').style.display = 'block';
                document.querySelector('#resultsSection h2').innerHTML = '游꿢 An치lisis Completado - Resultados Finales';
                return;
            }

            const container = document.getElementById('questionsContainer');
            container.innerHTML = `
                <div class="card question-card animate-fadeIn">
                    <div class="badge badge-secondary mb-3">
                        Pregunta ${index + 1} de ${questions.length}
                    </div>
                    <div class="question-text">
                        ${questions[index]}
                    </div>
                    <div class="response-buttons">
                        <button class="response-btn" onclick="answerQuestion(true, ${index})">
                            九 S칤
                        </button>
                        <button class="response-btn" onclick="answerQuestion(false, ${index})">
                            仇 No
                        </button>
                    </div>
                </div>
            `;

            if (currentAnswers[index] !== undefined) {
                const buttons = container.querySelectorAll('.response-btn');
                if (currentAnswers[index]) {
                    buttons[0].classList.add('selected');
                } else {
                    buttons[1].classList.add('selected');
                }
            }
        }

        function answerQuestion(answer, index) {
            currentAnswers[index] = answer;
            
            const buttons = document.querySelectorAll('.response-btn');
            buttons.forEach(btn => btn.classList.remove('selected'));
            if (answer) {
                buttons[0].classList.add('selected');
            } else {
                buttons[1].classList.add('selected');
            }

            updateLiveResults();

            setTimeout(() => {
                currentQuestionIndex = index + 1;
                updateProgressIndicator();
                showQuestion(currentQuestionIndex);
            }, 500);
        }

        function updateLiveResults() {
            const scores = calculateScores();
            const maxScore = Math.max(...Object.values(scores));
            const winner = Object.keys(scores).find(db => scores[db] === maxScore);

            displayScores(scores, maxScore);
            
            const answeredQuestions = currentAnswers.filter(a => a !== undefined).length;
            if (answeredQuestions > 0) {
                displayRecommendation(winner, maxScore);
            } else {
                const container = document.getElementById('recommendationContainer');
                container.innerHTML = `
                    <div class="recommendation animate-fadeIn">
                        <h3>游댩 Predicci칩n en Progreso</h3>
                        <p style="color: var(--color-text-secondary); font-size: var(--text-lg); text-align: center;">
                            Responde las preguntas para ver tu recomendaci칩n personalizada
                        </p>
                        <div class="badge badge-secondary mt-3">
                            Progreso: 0/${questions.length} preguntas
                        </div>
                    </div>
                `;
            }
        }

        function calculateScores() {
            const scores = {};
            
            Object.keys(databases).forEach(dbName => {
                let score = 0;
                const dbAnswers = databases[dbName];
                
                for (let i = 0; i < currentAnswers.length; i++) {
                    if (currentAnswers[i] !== undefined) {
                        if (currentAnswers[i] === true && dbAnswers[i] === 1) {
                            score++;
                        } else if (currentAnswers[i] === false && dbAnswers[i] === 0) {
                            score++;
                        }
                    }
                }
                
                scores[dbName] = score;
            });
            
            return scores;
        }

        function getDBTypeBadge(dbName) {
            if (dbName === 'MongoDB') return '<span class="database-type-badge badge-mongodb">NoSQL Leader</span>';
            if (dbName.includes('Google')) return '<span class="database-type-badge badge-google">Google Cloud</span>';
            if (dbName === 'DynamoDB') return '<span class="database-type-badge badge-aws">AWS</span>';
            if (dbName === 'PostgreSQL' || dbName === 'Redis' || dbName === 'YugabyteDB') 
                return '<span class="database-type-badge badge-opensource">Open Source</span>';
            return '';
        }

        function displayScores(scores, maxScore) {
            const container = document.getElementById('scoresContainer');
            container.innerHTML = '';

            const answeredQuestions = currentAnswers.filter(a => a !== undefined).length;
            const totalQuestions = questions.length;

            const sortedDatabases = Object.entries(scores)
                .sort(([,a], [,b]) => b - a);

            sortedDatabases.forEach(([dbName, score], index) => {
                const percentage = answeredQuestions > 0 ? (score / answeredQuestions) * 100 : 0;
                const isWinner = score === maxScore && answeredQuestions > 0 && score > 0;
                
                const scoreDiv = document.createElement('div');
                scoreDiv.className = `database-score animate-slideInLeft`;
                scoreDiv.style.animationDelay = `${index * 0.1}s`;
                
                scoreDiv.innerHTML = `
                    <div class="database-name ${isWinner ? 'text-gradient' : ''}">
                        ${isWinner ? '游끥 ' : ''}${dbName}
                        ${getDBTypeBadge(dbName)}
                    </div>
                    <div class="score-container">
                        <div class="score-bar">
                            <div class="score-fill" style="width: ${percentage}%"></div>
                        </div>
                        <div class="score-value">${score}/${answeredQuestions || totalQuestions}</div>
                    </div>
                `;
                
                container.appendChild(scoreDiv);
            });
        }

        function displayRecommendation(winner, maxScore) {
            const container = document.getElementById('recommendationContainer');
            const answeredQuestions = currentAnswers.filter(a => a !== undefined).length;
            const percentage = answeredQuestions > 0 ? Math.round((maxScore / answeredQuestions) * 100) : 0;
            
            const isComplete = answeredQuestions === questions.length;
            const title = isComplete ? '游꿢 Recomendaci칩n Final' : '游댩 Recomendaci칩n Actual';

            if (maxScore > 0) {
                container.innerHTML = `
                    <div class="recommendation animate-fadeIn">
                        <h3>${title}</h3>
                        <div class="database-name" style="font-size: var(--text-3xl); margin-bottom: var(--spacing-md);">
                            ${winner} ${getDBTypeBadge(winner)}
                        </div>
                        <div class="metric-value" style="margin-bottom: var(--spacing-md); color: var(--color-primary); font-size: var(--text-2xl); font-weight: 700;">
                            ${percentage}% de compatibilidad
                        </div>
                        <p style="color: var(--color-text-secondary); font-size: var(--text-lg);">
                            ${recommendations[winner]}
                        </p>
                        ${!isComplete ? `
                            <div class="badge badge-secondary mt-3">
                                Progreso: ${answeredQuestions}/${questions.length} preguntas
                            </div>
                        ` : ''}
                    </div>
                `;
            }
        }

        function resetMatrix() {
            currentAnswers = [];
            currentQuestionIndex = 0;
            document.getElementById('questionsContainer').style.display = 'block';
            document.getElementById('progressIndicator').style.display = 'flex';
            document.getElementById('resetButtonContainer').style.display = 'none';
            document.getElementById('technicalJustification').style.display = 'none';
            document.querySelector('#resultsSection h2').innerHTML = '游늵 Resultados en Tiempo Real';
            initializeMatrix();
        }

        function toggleJustification() {
            const justificationSection = document.getElementById('technicalJustification');
            const btn = document.getElementById('justificationBtn');
            
            if (justificationSection.style.display === 'none') {
                generateJustificationContent();
                justificationSection.style.display = 'block';
                btn.innerHTML = '游늶 Ocultar Justificaci칩n T칠cnica';
                justificationSection.scrollIntoView({ behavior: 'smooth' });
            } else {
                justificationSection.style.display = 'none';
                btn.innerHTML = '游늶 Ver Justificaci칩n T칠cnica Detallada';
            }
        }

        function generateJustificationContent() {
            const container = document.getElementById('justificationContent');
            container.innerHTML = '';

            technicalJustifications.forEach((justification, index) => {
                if (currentAnswers[index] !== undefined) {
                    const userAnswer = currentAnswers[index];
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'justification-question animate-fadeIn';
                    questionDiv.style.animationDelay = `${index * 0.05}s`;

                    const scores = {};
                    Object.keys(databases).forEach(dbName => {
                        scores[dbName] = databases[dbName][index];
                    });

                    questionDiv.innerHTML = `
                        <div class="question-title">
                            <span>仇</span>
                            ${justification.question}
                            <span class="user-response ${userAnswer ? 'yes' : 'no'}">
                                ${userAnswer ? '九 S칤' : '仇 No'}
                            </span>
                        </div>
                        <div class="justification-content">
                            <div style="margin-bottom: var(--spacing-md);">
                                <strong>Puntuaciones por tecnolog칤a:</strong>
                                ${Object.entries(scores).map(([db, score]) => 
                                    `<span class="tech-score score-${score}">
                                        ${db}: ${score === 1 ? '九' : '九'}
                                    </span>`
                                ).join('')}
                            </div>
                            <div class="tech-explanation">
                                <strong style="color: var(--color-primary);">An치lisis Arquitect칩nico:</strong><br><br>
                                ${Object.entries(justification.explanations).map(([db, explanation]) => {
                                    const score = scores[db];
                                    const matches = (userAnswer && score === 1) || (!userAnswer && score === 0);
                                    return `<div style="margin-bottom: var(--spacing-sm); padding: 8px; border-radius: 4px; ${matches ? 'background: rgba(0, 237, 100, 0.05);' : 'background: rgba(239, 68, 68, 0.05);'}">
                                        <strong>${db}</strong> 
                                        <span class="tech-score score-${score}">${score === 1 ? 'S칤' : 'No'}</span>
                                        ${matches ? '<span style="color: var(--color-primary); font-weight: bold;">九 Match</span>' : '<span style="color: #EF4444; font-weight: bold;">九 No Match</span>'}
                                        <br>
                                        <span style="color: var(--color-text-secondary);">${explanation}</span>
                                    </div>`;
                                }).join('')}
                            </div>
                        </div>
                    `;

                    container.appendChild(questionDiv);
                }
            });

            // Agregar resumen al final
            const summary = document.createElement('div');
            summary.className = 'recommendation animate-fadeIn';
            summary.style.marginTop = 'var(--spacing-xl)';
            
            const scores = calculateScores();
            const sortedDatabases = Object.entries(scores).sort(([,a], [,b]) => b - a);
            
            summary.innerHTML = `
                <h3 style="color: var(--color-primary);">游늳 Resumen de Compatibilidad</h3>
                <p style="margin-bottom: var(--spacing-lg);">Basado en tus ${currentAnswers.filter(a => a !== undefined).length} respuestas:</p>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: var(--spacing-md);">
                    ${sortedDatabases.map(([db, score], index) => {
                        const percentage = Math.round((score / currentAnswers.filter(a => a !== undefined).length) * 100);
                        const isTop = index === 0;
                        return `
                            <div style="padding: var(--spacing-md); background: ${isTop ? 'rgba(0, 237, 100, 0.1)' : 'rgba(255, 255, 255, 0.05)'}; border-radius: var(--radius-md); border: 1px solid ${isTop ? 'var(--color-primary)' : 'rgba(255, 255, 255, 0.1)'};">
                                <div style="font-weight: 700; margin-bottom: var(--spacing-xs);">
                                    ${isTop ? '游끥 ' : ''}${db}
                                </div>
                                <div style="font-size: var(--text-2xl); color: ${isTop ? 'var(--color-primary)' : 'var(--color-text-secondary)'};">
                                    ${percentage}%
                                </div>
                                <div style="font-size: var(--text-sm); color: var(--color-text-secondary);">
                                    ${score}/${currentAnswers.filter(a => a !== undefined).length} coincidencias
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            
            container.appendChild(summary);
        }

        // Inicializar la matriz al cargar la p치gina
        document.addEventListener('DOMContentLoaded', initializeMatrix);
    </script>
</body>
</html>