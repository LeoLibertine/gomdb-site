<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoMDB - Matriz de Decisi√≥n Interactiva v2</title>
    <style>
        :root {
            --color-primary: #00ED64;
            --color-primary-light: rgba(0, 237, 100, 0.1);
            --color-accent: #5644D4;
            --color-bg-primary: #001124;
            --color-bg-secondary: #0D2A3D;
            --color-bg-tertiary: #112331;
            --color-bg-card: rgba(13, 42, 61, 0.5);
            --color-text-primary: #FFFFFF;
            --color-text-secondary: #B8C5D6;
            --color-text-dark: #001124;
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --spacing-2xl: 3rem;
            --spacing-3xl: 4rem;
            --radius-sm: 0.25rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
            --radius-full: 9999px;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            --text-3xl: 1.875rem;
            --transition-base: all 0.3s ease;
            --transition-slow: all 0.5s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--color-bg-primary);
            color: var(--color-text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .hero {
            min-height: 100vh;
            position: relative;
            padding: var(--spacing-2xl) var(--spacing-lg);
        }

        .hero-background {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
            z-index: -2;
        }

        .hero-blur {
            position: fixed;
            width: 400px;
            height: 400px;
            border-radius: 50%;
            filter: blur(100px);
            opacity: 0.3;
            z-index: -1;
        }

        .hero-blur-primary {
            background: var(--color-primary);
            top: 10%;
            right: 10%;
            animation: float 20s ease-in-out infinite;
        }

        .hero-blur-accent {
            background: var(--color-accent);
            bottom: 10%;
            left: 10%;
            animation: float 20s ease-in-out infinite reverse;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0); }
            33% { transform: translate(30px, -30px); }
            66% { transform: translate(-20px, 20px); }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-md);
            border-radius: var(--radius-full);
            font-size: var(--text-sm);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge-primary {
            background: var(--color-primary-light);
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
        }

        .badge-secondary {
            background: rgba(86, 68, 212, 0.1);
            color: var(--color-accent);
            border: 1px solid var(--color-accent);
        }

        .text-gradient {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: var(--spacing-lg);
        }

        .card {
            background: var(--color-bg-card);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            backdrop-filter: blur(10px);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-md) var(--spacing-xl);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-lg);
            background: transparent;
            color: var(--color-primary);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-base);
            text-decoration: none;
            font-size: var(--text-base);
        }

        .btn:hover {
            background: var(--color-primary);
            color: var(--color-text-dark);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 237, 100, 0.3);
        }

        .animate-fadeIn {
            animation: fadeIn 0.5s ease-out;
        }

        .animate-slideInLeft {
            animation: slideInLeft 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        .mb-3 { margin-bottom: var(--spacing-md); }
        .mb-4 { margin-bottom: var(--spacing-lg); }
        .mb-5 { margin-bottom: var(--spacing-xl); }
        .mt-3 { margin-top: var(--spacing-md); }
        .mt-4 { margin-top: var(--spacing-lg); }
        .text-center { text-align: center; }

        .question-card {
            background: linear-gradient(135deg, var(--color-bg-secondary) 0%, rgba(13, 42, 61, 0.8) 100%);
            border: 1px solid rgba(0, 237, 100, 0.2);
            margin-bottom: var(--spacing-lg);
            transition: all var(--transition-base);
        }

        .question-card:hover {
            border-color: var(--color-primary);
            box-shadow: 0 0 20px rgba(0, 237, 100, 0.2);
        }

        .question-text {
            color: var(--color-text-primary);
            font-size: var(--text-lg);
            margin-bottom: var(--spacing-lg);
            line-height: 1.6;
        }

        .response-buttons {
            display: flex;
            gap: var(--spacing-md);
        }

        .response-btn {
            flex: 1;
            padding: var(--spacing-md) var(--spacing-lg);
            border: 2px solid transparent;
            border-radius: var(--radius-lg);
            background: rgba(255, 255, 255, 0.05);
            color: var(--color-text-secondary);
            cursor: pointer;
            transition: all var(--transition-base);
            font-weight: 600;
        }

        .response-btn:hover {
            background: rgba(0, 237, 100, 0.1);
            border-color: var(--color-primary);
            color: var(--color-text-primary);
        }

        .response-btn.selected {
            background: var(--color-primary);
            color: var(--color-text-dark);
            border-color: var(--color-primary);
        }

        .results-section {
            margin-top: var(--spacing-3xl);
            padding: var(--spacing-xl);
            background: linear-gradient(135deg, var(--color-bg-card) 0%, rgba(86, 68, 212, 0.1) 100%);
            border-radius: var(--radius-xl);
            border: 1px solid rgba(0, 237, 100, 0.2);
        }

        .database-score {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
            background: var(--color-bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all var(--transition-base);
        }

        .database-score:hover {
            transform: translateX(4px);
            border-color: var(--color-primary);
        }

        .database-name {
            font-size: var(--text-xl);
            font-weight: 700;
            color: var(--color-text-primary);
        }

        .score-container {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .score-bar {
            width: 200px;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-full);
            overflow: hidden;
            position: relative;
        }

        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary) 0%, var(--color-accent) 100%);
            border-radius: var(--radius-full);
            transition: width var(--transition-slow);
            position: relative;
        }

        .score-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .score-value {
            font-size: var(--text-2xl);
            font-weight: 700;
            color: var(--color-primary);
            min-width: 60px;
            text-align: center;
        }

        .progress-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: var(--spacing-xl);
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .progress-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all var(--transition-base);
        }

        .progress-dot.completed {
            background: var(--color-primary);
            box-shadow: 0 0 10px rgba(0, 237, 100, 0.5);
        }

        .progress-dot.current {
            background: var(--color-accent);
            animation: pulse 2s ease-in-out infinite;
        }

        .recommendation {
            background: linear-gradient(135deg, var(--color-primary-light) 0%, rgba(86, 68, 212, 0.1) 100%);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            margin-top: var(--spacing-xl);
            text-align: center;
        }

        .recommendation h3 {
            color: var(--color-primary);
            margin-bottom: var(--spacing-md);
        }

        .reset-btn {
            margin-top: var(--spacing-xl);
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid #EF4444;
            color: #EF4444;
        }

        .reset-btn:hover {
            background: #EF4444;
            color: white;
        }

        .header-section {
            text-align: center;
            margin-bottom: var(--spacing-3xl);
        }

        .subtitle {
            font-size: var(--text-xl);
            color: var(--color-text-secondary);
            margin-bottom: var(--spacing-xl);
        }

        .technical-justification {
            margin-top: var(--spacing-3xl);
            background: linear-gradient(135deg, var(--color-bg-tertiary) 0%, rgba(17, 35, 49, 0.8) 100%);
            border: 1px solid rgba(86, 68, 212, 0.3);
            border-radius: var(--radius-xl);
            padding: var(--spacing-2xl);
        }

        .justification-question {
            background: var(--color-bg-secondary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            border-left: 4px solid var(--color-primary);
        }

        .question-title {
            color: var(--color-primary);
            font-size: var(--text-lg);
            font-weight: 700;
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .user-response {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-md);
            border-radius: var(--radius-full);
            font-weight: 600;
            font-size: var(--text-sm);
            margin-left: var(--spacing-md);
        }

        .user-response.yes {
            background: rgba(0, 237, 100, 0.2);
            color: var(--color-primary);
        }

        .user-response.no {
            background: rgba(239, 68, 68, 0.2);
            color: #EF4444;
        }

        .justification-content {
            color: var(--color-text-secondary);
            line-height: 1.6;
        }

        .tech-score {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-md);
            font-weight: 600;
            font-size: var(--text-sm);
            margin: 0 var(--spacing-xs);
        }

        .tech-score.score-1 {
            background: rgba(0, 237, 100, 0.2);
            color: var(--color-primary);
        }

        .tech-score.score-0 {
            background: rgba(239, 68, 68, 0.2);
            color: #EF4444;
        }

        .tech-explanation {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-md);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            border-left: 3px solid var(--color-accent);
        }

        .toggle-justification {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-primary) 100%);
            margin-top: var(--spacing-xl);
        }

        .toggle-justification:hover {
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(86, 68, 212, 0.4);
        }

        .database-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 8px;
            font-weight: 600;
        }

        .badge-mongodb { background: #13AA52; color: white; }
        .badge-aws { background: #FF9900; color: white; }
        .badge-google { background: #4285F4; color: white; }
        .badge-opensource { background: #6B7280; color: white; }
    </style>
</head>
<body>
    <section class="hero">
        <div class="hero-background"></div>
        <div class="hero-blur hero-blur-primary"></div>
        <div class="hero-blur hero-blur-accent"></div>
        
        <div class="container">
            <div class="header-section">
                <div class="badge badge-primary mb-4">
                    <span>üéØ</span>
                    Arquitectura de Datos 2025
                </div>
                <h1 class="text-gradient">Matriz de Decisi√≥n Interactiva v2.0</h1>
                <p class="subtitle">
                    Eval√∫a 9 tecnolog√≠as de bases de datos l√≠deres del mercado<br>
                    respondiendo 19 preguntas estrat√©gicas para encontrar la soluci√≥n perfecta
                </p>
                <div style="margin-top: 20px; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <span class="badge badge-secondary">MongoDB</span>
                    <span class="badge badge-secondary">PostgreSQL</span>
                    <span class="badge badge-secondary">DynamoDB</span>
                    <span class="badge badge-secondary">BigQuery</span>
                    <span class="badge badge-secondary">Firestore</span>
                    <span class="badge badge-secondary">Bigtable</span>
                    <span class="badge badge-secondary">AlloyDB</span>
                    <span class="badge badge-secondary">YugabyteDB</span>
                    <span class="badge badge-secondary">Redis</span>
                </div>
            </div>

            <div class="progress-indicator" id="progressIndicator"></div>
            <div id="questionsContainer"></div>

            <div class="results-section" id="resultsSection">
                <h2 class="text-center mb-4">üìä Resultados en Tiempo Real</h2>
                <div id="scoresContainer"></div>
                <div id="recommendationContainer"></div>
                <div class="text-center" id="resetButtonContainer" style="display: none;">
                    <button class="btn toggle-justification" onclick="toggleJustification()" id="justificationBtn">
                        üìã Ver Justificaci√≥n T√©cnica Detallada
                    </button>
                    <button class="btn reset-btn" onclick="resetMatrix()">
                        üîÑ Realizar Nueva Evaluaci√≥n
                    </button>
                </div>
            </div>

            <div class="technical-justification" id="technicalJustification" style="display: none;">
                <h2 class="text-center mb-4">üî¨ Justificaci√≥n T√©cnica Detallada</h2>
                <p class="text-center mb-5" style="color: var(--color-text-secondary);">
                    An√°lisis arquitect√≥nico caso por caso de cada tecnolog√≠a de base de datos
                </p>
                <div id="justificationContent"></div>
            </div>
        </div>
    </section>
    <script>
        const questions = [
            "¬øNecesita realizar consultas complejas (joins, subqueries, etc.)?",
            "¬øRequiere una soluci√≥n basada en protocolo abierto para evitar vendor lock-in?",
            "¬øNecesita soporte de transacciones ACID complejas (m√∫ltiples registros)?",
            "¬øRequiere m√≠nimo impacto/overhead de operaciones (Serverless/Full Managed)?",
            "¬øLa base de datos ser√° utilizada para anal√≠tica sobre grandes vol√∫menes de datos estructurados (Data Warehouse)?",
            "¬øRequiere realizar consultas geoespaciales avanzadas?",
            "¬øLas operaciones con datos de tipo fecha (Time-Series) son muy frecuentes?",
            "¬øNecesita alta disponibilidad de escritura nativa multi-regi√≥n (Activo-Activo)?",
            "¬øRequiere un modelo de datos enriquecido (Documentos, JSON nativo)?",
            "¬øLa base de datos ser√° usada para cargas de trabajo poco frecuentes (modelo Serverless real, pago por uso)?",
            "¬øNecesita un modelo de datos nativo de Grafos?",
            "¬øRequiere validaci√≥n estricta y forzada de esquema?",
            "¬øNecesita paginaci√≥n tradicional eficiente con conteo total (COUNT(*))?",
            "¬øEl uso principal ser√° como cach√© en memoria de ultra baja latencia?",
            "¬øNecesita operaciones simples de clave-valor (Key-Value) a escala masiva?",
            "¬øEl caso de uso principal es Business Intelligence (BI) interactivo o ejecuci√≥n de modelos ML con SQL?",
            "¬øLa aplicaci√≥n requiere sincronizaci√≥n en tiempo real con clientes web/m√≥viles y soporte offline?",
            "¬øRequiere rendimiento OLTP superior a PostgreSQL est√°ndar pero con 100% compatibilidad?",
            "¬øNecesita ingerir flujos de datos masivos (millones ops/seg) para IoT, Ad-Tech o perfiles en tiempo real?"
        ];

        const databases = {
            'MongoDB':           [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0],
            'PostgreSQL':        [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
            'Redis':             [0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            'DynamoDB':          [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            'Google BigQuery':   [1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0],
            'Google Firestore':  [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            'Google Bigtable':   [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            'Google AlloyDB':    [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0],
            'YugabyteDB':        [1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1]
        };

        const technicalJustifications = [
            // Primeras 5 justificaciones t√©cnicas completas
            {
                question: "¬øConsultas complejas? (joins, subqueries, etc.)",
                explanations: {
                    "MongoDB": "Con su Aggregation Pipeline es extremadamente potente y puede manejar consultas muy complejas de manera eficiente, incluyendo $lookup para joins y transformaciones multi-etapa.",
                    "PostgreSQL": "Las bases de datos relacionales son los reyes aqu√≠. PostgreSQL maneja joins complejos, subqueries y agregaciones con optimizadores de consultas avanzados.",
                    "Redis": "Es un almac√©n clave-valor. Las consultas complejas van contra su arquitectura fundamental de simplicidad y velocidad.",
                    "DynamoDB": "No est√° dise√±ada para esto. Su modelo de acceso se basa en claves primarias. Realizar 'joins' es ineficiente o imposible.",
                    "Google BigQuery": "Utiliza SQL est√°ndar y est√° pensado para an√°lisis complejo de grandes datasets con joins, subconsultas y funciones anal√≠ticas avanzadas.",
                    "Google Firestore": "Ofrece consultas sencillas basadas en propiedades. No soporta joins entre colecciones ni subconsultas multi-documento.",
                    "Google Bigtable": "No admite joins ni SQL. Sus accesos son mediante row keys y rangos, sin lenguaje de consultas declarativo.",
                    "Google AlloyDB": "Compatible con PostgreSQL, soporta todo el repertorio SQL complejo con optimizaciones adicionales de Google para mejor rendimiento.",
                    "YugabyteDB": "Mediante su interfaz YSQL compatible con PostgreSQL, soporta plenamente joins y consultas SQL complejas en un entorno distribuido."
                }
            },
            {
                question: "¬øProtocolo abierto / Evitar Lock-in?",
                explanations: {
                    "MongoDB": "Basado en motor open source con protocolo abierto BSON. La migraci√≥n entre diferentes proveedores es factible.",
                    "PostgreSQL": "Motor de c√≥digo abierto reconocido mundialmente. Puedes migrar a otro proveedor cloud o on-premise con esfuerzo relativamente bajo.",
                    "Redis": "Open source con protocolo completamente abierto. M√°xima portabilidad entre diferentes implementaciones.",
                    "DynamoDB": "Completamente propietario de AWS con API √∫nica. Alto lock-in con pocas alternativas compatibles.",
                    "Google BigQuery": "Servicio 100% propietario de Google Cloud. No existe versi√≥n open source para migrar.",
                    "Google Firestore": "Servicio cerrado de Google sin motor open source equivalente. Alto vendor lock-in.",
                    "Google Bigtable": "Servicio propietario, aunque parcialmente compatible con HBase. Dependencia fuerte de GCP.",
                    "Google AlloyDB": "Basado en PostgreSQL pero con optimizaciones propietarias de Google. Portabilidad parcial.",
                    "YugabyteDB": "Open source (Apache 2.0) desplegable en cualquier infraestructura con APIs PostgreSQL y Cassandra compatibles."
                }
            },
            {
                question: "¬øTransacciones ACID complejas (m√∫ltiples registros)?",
                explanations: {
                    "MongoDB": "Soporta transacciones ACID multi-documento desde v4.0, permitiendo agrupar operaciones en m√∫ltiples colecciones con atomicidad completa.",
                    "PostgreSQL": "Referente en transacciones ACID. Soporta transacciones multi-fila, multi-tabla con atomicidad completa y aislamiento configurable.",
                    "Redis": "MULTI/EXEC agrupa operaciones pero sin aislamiento robusto ni durabilidad ACID completa. No es para transacciones complejas.",
                    "DynamoDB": "Transacciones limitadas a 100 operaciones y 4MB. No tan flexible como SQL tradicional pero funcional para casos b√°sicos.",
                    "Google BigQuery": "No es transaccional. Es append-only para an√°lisis, no para transacciones OLTP.",
                    "Google Firestore": "Soporta transacciones hasta 500 documentos con aislamiento serializable, pero con restricciones de tiempo (60s) y tama√±o (10MB).",
                    "Google Bigtable": "Solo garantiza atomicidad a nivel de fila individual, no transacciones multi-fila.",
                    "Google AlloyDB": "Al ser PostgreSQL, soporta totalmente transacciones ACID complejas con durabilidad mejorada por su arquitectura.",
                    "YugabyteDB": "Dise√±ado como SQL distribuido CP con transacciones distribuidas ACID usando Raft para consenso global."
                }
            },
            {
                question: "¬øM√≠nimo impacto operativo? (Serverless/Full Managed)",
                explanations: {
                    "MongoDB": "MongoDB Atlas ofrece opciones totalmente administradas incluyendo Atlas Serverless con escalado autom√°tico y pago por uso.",
                    "PostgreSQL": "RDS requiere gestionar instancias, tama√±o, almacenamiento y par√°metros. No es serverless, requiere planificaci√≥n de capacidad.",
                    "Redis": "Como servicio administrado (ElastiCache, Redis Cloud) libera de gesti√≥n pero requiere nodos activos siempre corriendo.",
                    "DynamoDB": "Emblem√°tica en serverless: no hay servidores que aprovisionar, escala autom√°ticamente seg√∫n demanda, pago por uso real.",
                    "Google BigQuery": "Totalmente serverless, no hay clusters que crear. Escala autom√°ticamente sin intervenci√≥n alguna.",
                    "Google Firestore": "Fully-managed y serverless. Escala autom√°ticamente seg√∫n tr√°fico sin configuraci√≥n de infraestructura.",
                    "Google Bigtable": "Requiere aprovisionar nodos manualmente y gestionar capacidad. No es serverless aunque sea gestionado.",
                    "Google AlloyDB": "Servicio gestionado pero requiere seleccionar instancias fijas. No tiene modo serverless actualmente.",
                    "YugabyteDB": "Requiere gestionar un cl√∫ster de servidores. Incluso en Yugabyte Cloud necesitas definir topolog√≠a."
                }
            },
            {
                question: "¬øAnal√≠tica / Data Warehouse?",
                explanations: {
                    "MongoDB": "Base operacional, no anal√≠tica. Para an√°lisis masivos necesitar√≠as herramientas complementarias como MongoDB Charts o exportar a un warehouse.",
                    "PostgreSQL": "Usar una base transaccional como data warehouse es un anti-patr√≥n. No escalar√° ni rendir√° para consultas anal√≠ticas masivas.",
                    "Redis": "Cache en memoria. Usar como data warehouse ser√≠a t√©cnicamente incorrecto y extremadamente costoso por la RAM requerida.",
                    "DynamoDB": "Almac√©n operacional clave-valor. No dise√±ado para consultas anal√≠ticas complejas cross-record. Exportar a S3+Athena para an√°lisis.",
                    "Google BigQuery": "Herramienta dise√±ada espec√≠ficamente para esto. Data warehouse serverless con capacidad de petabytes y SQL est√°ndar.",
                    "Google Firestore": "Base NoSQL operacional. Para anal√≠tica se deben exportar datos a BigQuery, no es su prop√≥sito.",
                    "Google Bigtable": "Puede almacenar petabytes pero no proporciona SQL ni agregaciones nativas. Requiere herramientas externas para an√°lisis.",
                    "Google AlloyDB": "Tiene capacidades h√≠bridas HTAP con motor columnar pero no reemplaza un data warehouse dedicado para petabytes.",
                    "YugabyteDB": "Orientado a OLTP distribuido, no a OLAP. Para anal√≠tica masiva mejor usar un warehouse dedicado como BigQuery o Redshift."
                }
            },
            {
                question: "¬øConsultas geoespaciales avanzadas?",
                explanations: {
                    "MongoDB": "Soporte geoespacial nativo excelente con √≠ndices 2d/2dsphere y operadores como $near, $geoWithin, $geoIntersects. Ideal para aplicaciones con mapas.",
                    "PostgreSQL": "Con PostGIS es el est√°ndar de oro en geodatos open source. Cientos de funciones para c√°lculos avanzados, transformaciones de coordenadas y an√°lisis GIS.",
                    "Redis": "Comandos geo b√°sicos (GEORADIUS, GEOADD) para puntos y distancias simples. Limitado comparado con soluciones especializadas.",
                    "DynamoDB": "Sin soporte geoespacial nativo. Requiere implementaci√≥n manual con geohashes como workaround, lo cual es complejo y limitado.",
                    "Google BigQuery": "BigQuery GIS permite operaciones geoespaciales en SQL sobre datasets masivos. Excelente para an√°lisis geo pero no para queries en tiempo real.",
                    "Google Firestore": "Sin tipo geoespacial nativo. Debe usar t√©cnica de geohashes manualmente, no es una soluci√≥n completa ni eficiente.",
                    "Google Bigtable": "No implementa funciones geoespaciales. Cualquier c√°lculo geo requiere procesamiento externo en la aplicaci√≥n.",
                    "Google AlloyDB": "Compatible con PostGIS al ser PostgreSQL, hereda todas las capacidades geoespaciales con optimizaciones adicionales de Google.",
                    "YugabyteDB": "Soporte parcial de PostGIS pero con limitaciones en entorno distribuido. Funciones b√°sicas funcionan pero no todas las avanzadas."
                }
            },
            {
                question: "¬øOperaciones frecuentes con fechas (Time-Series)?",
                explanations: {
                    "MongoDB": "Excelente para time-series con TTL indexes para expiraci√≥n autom√°tica y colecciones time-series optimizadas desde v5.0 con almacenamiento columnar interno.",
                    "PostgreSQL": "Con TimescaleDB (extensi√≥n) se convierte en potente base para series temporales con particionado autom√°tico y compresi√≥n.",
                    "Redis": "Excelente para time-series en tiempo real con m√≥dulo RedisTimeSeries. Ideal para m√©tricas recientes en memoria con downsampling.",
                    "DynamoDB": "Patr√≥n com√∫n para time-series usando composite keys (deviceId + timestamp). Escalabilidad masiva para ingesta de eventos IoT.",
                    "Google BigQuery": "Puede almacenar series hist√≥ricas masivas para an√°lisis pero no para ingesta en tiempo real punto a punto. Mejor para batch.",
                    "Google Firestore": "Limitaciones de throughput (1 escritura/seg por documento) lo hacen inadecuado para time-series de alta frecuencia.",
                    "Google Bigtable": "Particularmente bien adaptada para series de tiempo e IoT. Dise√±o de row key con timestamp permite acceso eficiente a datos recientes.",
                    "Google AlloyDB": "Puede manejar series de tiempo como PostgreSQL con mejor rendimiento de I/O. Compatible con TimescaleDB en teor√≠a.",
                    "YugabyteDB": "Soporta time-series distribuidas con particionado por rangos de tiempo. Buena opci√≥n para series con requerimientos ACID."
                }
            },
            {
                question: "¬øEscritura nativa multi-regi√≥n (Activo-Activo)?",
                explanations: {
                    "MongoDB": "Global Clusters permite escrituras locales activas en m√∫ltiples regiones con resoluci√≥n de conflictos last-write-wins y zonas geogr√°ficas.",
                    "PostgreSQL": "Requiere soluciones externas complejas como BDR. No es capacidad nativa out-of-the-box, propenso a conflictos.",
                    "Redis": "Solo master-slave tradicional en versi√≥n open source. Multi-master requiere Redis Enterprise con CRDTs (soluci√≥n comercial).",
                    "DynamoDB": "Global Tables ofrece verdadero activo-activo multi-regi√≥n administrado autom√°ticamente con resoluci√≥n de conflictos integrada.",
                    "Google BigQuery": "Multi-regi√≥n para disponibilidad pero no es transaccional activo-activo. Los datos se replican pero no hay escrituras concurrentes.",
                    "Google Firestore": "Multi-regi√≥n autom√°tica con consistencia fuerte global usando Spanner internamente. Escrituras desde cualquier regi√≥n.",
                    "Google Bigtable": "Replicaci√≥n entre cl√∫steres multi-regi√≥n con escrituras concurrentes y consistencia eventual. Configuraci√≥n manual requerida.",
                    "Google AlloyDB": "Solo cl√∫steres secundarios de lectura cross-region, no multi-master verdadero. Modelo activo-pasivo para DR.",
                    "YugabyteDB": "Dise√±ado para distribuci√≥n geogr√°fica con consenso Raft. Escrituras desde cualquier regi√≥n con consistencia configurable."
                }
            },
            {
                question: "¬øModelo de datos enriquecido (Documentos, JSON nativo)?",
                explanations: {
                    "MongoDB": "L√≠der indiscutible en documentos. Base nativa BSON con esquemas flexibles, subdocumentos, arrays y consultas ricas sobre JSON anidado.",
                    "PostgreSQL": "Soporte JSONB excelente. Permite almacenar, indexar (GIN) y consultar documentos JSON eficientemente con operadores y funciones.",
                    "Redis": "Almacena strings por defecto. Requiere m√≥dulo RedisJSON para manejo real de documentos con path queries.",
                    "DynamoDB": "Soporta documentos JSON con estructuras anidadas (Maps, Lists) y operaciones por ruta. Modelo documento-clave-valor h√≠brido.",
                    "Google BigQuery": "Soporta JSON y estructuras anidadas para an√°lisis pero no es base documental transaccional. M√°s para ETL que OLTP.",
                    "Google Firestore": "Base documental JSON nativa. Estructura flexible por documento con campos anidados, arrays y mapas. Similar a MongoDB.",
                    "Google Bigtable": "Almacena bytes en columnas, no tiene noci√≥n de documentos JSON. Requerir√≠a serializaci√≥n manual.",
                    "Google AlloyDB": "Hereda soporte JSONB completo de PostgreSQL con las mismas capacidades de indexaci√≥n y consulta.",
                    "YugabyteDB": "Compatible con JSONB de PostgreSQL en YSQL. Documentos JSON distribuidos con √≠ndices secundarios globales."
                }
            },
            {
                question: "¬øCargas poco frecuentes (Serverless real)?",
                explanations: {
                    "MongoDB": "Atlas Serverless escala a cero y cobra solo por operaciones realizadas. Ideal para prototipos y aplicaciones intermitentes.",
                    "PostgreSQL": "RDS factura por hora est√© activa o no. No hay modo serverless real, siempre pagas por capacidad reservada.",
                    "Redis": "Requiere nodos activos continuamente. ElastiCache no escala a cero. Pagas 24/7 por la memoria reservada.",
                    "DynamoDB": "On-Demand mode perfecto para cargas espor√°dicas. Pagas exactamente por cada operaci√≥n, sin m√≠nimos.",
                    "Google BigQuery": "Completamente on-demand, pagas por TB procesado solo cuando ejecutas consultas. Cero costo sin consultas.",
                    "Google Firestore": "Modelo pago por operaci√≥n sin servidores que mantener. Perfecto para apps con tr√°fico irregular.",
                    "Google Bigtable": "Requiere m√≠nimo 1 nodo siempre activo por cl√∫ster. No es serverless, pagas aunque no uses.",
                    "Google AlloyDB": "Instancias fijas sin modo serverless. Siempre incurres costo de instancia primaria encendida.",
                    "YugabyteDB": "Requiere cluster activo m√≠nimo. No tiene escalado a cero autom√°tico ni en Yugabyte Cloud."
                }
            },
            {
                question: "¬øModelo de Grafos nativo?",
                explanations: {
                    "MongoDB": "No es base de grafos. Modelar relaciones de grafos requerir√≠a agregaciones complicadas con m√∫ltiples $lookup, ineficiente para traversals.",
                    "PostgreSQL": "No es base de grafos. Consultas recursivas con WITH RECURSIVE ser√≠an muy lentas para grafos complejos.",
                    "Redis": "Requiere m√≥dulo RedisGraph separado (ahora deprecado). No es funcionalidad nativa del core.",
                    "DynamoDB": "Modelo clave-valor incompatible con traversals de grafos. Cada salto requerir√≠a query separada, inadecuado.",
                    "Google BigQuery": "Puede procesar datos de grafos anal√≠ticamente con SQL recursivo pero no para queries transaccionales de grafos.",
                    "Google Firestore": "Sin soporte de grafos. Cada relaci√≥n requerir√≠a query separada. No hay traversals ni algoritmos de grafos.",
                    "Google Bigtable": "No hay consultas de grafos. Modelo de filas/columnas inadecuado para relaciones complejas de grafos.",
                    "Google AlloyDB": "Sin modelo de grafos nativo. Solo esquema relacional tradicional que no optimiza para traversals.",
                    "YugabyteDB": "No es motor de grafos aunque puede modelar relaciones en tablas SQL. No optimizado para este caso."
                }
            },
            {
                question: "¬øValidaci√≥n estricta de esquema?",
                explanations: {
                    "MongoDB": "Schema Validation opcional pero potente usando JSON Schema. Puede forzar estructura cuando se requiere manteniendo flexibilidad base.",
                    "PostgreSQL": "Validaci√≥n estricta por definici√≥n. Constraints, tipos de datos, foreign keys y reglas de integridad robustas enforced siempre.",
                    "Redis": "Sin noci√≥n de esquema. Almacena bytes/strings arbitrarios. Toda validaci√≥n recae en la aplicaci√≥n.",
                    "DynamoDB": "Schema-less excepto keys. La validaci√≥n de atributos recae completamente en la aplicaci√≥n. No hay tipos enforced.",
                    "Google BigQuery": "Requiere definir esquema de tablas con tipos de datos enforced estrictamente. No permite datos fuera de esquema.",
                    "Google Firestore": "Schema-less por dise√±o. Sin validaci√≥n nativa de tipos. Puede usar Security Rules para validaci√≥n b√°sica.",
                    "Google Bigtable": "Sin esquema m√°s all√° de column families. Valores son bytes sin tipo. No hay validaci√≥n.",
                    "Google AlloyDB": "Igual que PostgreSQL: esquema fijo con tipos, constraints y validaci√≥n estricta autom√°tica.",
                    "YugabyteDB": "YSQL impone esquemas con tipos como PostgreSQL. YCQL tambi√©n define columnas con tipos est√°ticos."
                }
            },
            {
                question: "¬øPaginaci√≥n tradicional con conteo total?",
                explanations: {
                    "MongoDB": "Soporta count() y skip()/limit() para paginaci√≥n. Puede ser lento en colecciones muy grandes pero funcional.",
                    "PostgreSQL": "COUNT(*) y OFFSET/LIMIT optimizados por el query planner. Funciona bien para la mayor√≠a de casos de paginaci√≥n.",
                    "Redis": "No aplica concepto de paginaci√≥n tradicional sobre m√∫ltiples claves. Solo dentro de estructuras como sorted sets.",
                    "DynamoDB": "COUNT requiere Scan completo muy costoso. Usa paginaci√≥n por tokens (LastEvaluatedKey), no offset tradicional.",
                    "Google BigQuery": "Soporta COUNT(*) y LIMIT/OFFSET pero costoso para paginaci√≥n interactiva web. M√°s para an√°lisis batch.",
                    "Google Firestore": "Paginaci√≥n por cursor con startAfter(). Ahora soporta count() agregaci√≥n pero no offset arbitrario.",
                    "Google Bigtable": "Sin mecanismo de contar filas eficiente. Usa scanners con tokens de continuaci√≥n, no paginaci√≥n tradicional.",
                    "Google AlloyDB": "Igual que PostgreSQL con COUNT(*) y LIMIT/OFFSET est√°ndar, posiblemente con optimizaciones adicionales.",
                    "YugabyteDB": "COUNT() distribuido y paginaci√≥n SQL est√°ndar. El count puede ser m√°s lento por naturaleza distribuida."
                }
            },
            {
                question: "¬øUso principal como cach√© en memoria?",
                explanations: {
                    "MongoDB": "Base persistente en disco con cache interno. No dise√±ada como cache primario, mejor usar Redis para eso.",
                    "PostgreSQL": "Base persistente en disco. Usarla como cach√© ser√≠a arquitect√≥nicamente incorrecto, lento y costoso.",
                    "Redis": "Definici√≥n misma de cach√© en memoria. Latencia de microsegundos, estructuras de datos especializadas, TTL autom√°tico.",
                    "DynamoDB": "Base persistente con latencia de milisegundos. Para cach√© usar DAX encima. No es cache nativo.",
                    "Google BigQuery": "Data warehouse para an√°lisis. Totalmente inapropiado para caching, latencias de segundos.",
                    "Google Firestore": "Base persistente NoSQL. No compite con caches in-memory, latencias de milisegundos vs microsegundos.",
                    "Google Bigtable": "Latencia de milisegundos para datos persistentes. No es cache, aunque r√°pida para base persistente.",
                    "Google AlloyDB": "Base persistente ACID con durabilidad. No es vol√°til ni optimizada para cache temporal.",
                    "YugabyteDB": "Base distribuida persistente con overhead de consenso. No es apropiada como cache layer."
                }
            },
            {
                question: "¬øOperaciones clave-valor a escala masiva?",
                explanations: {
                    "MongoDB": "Puede hacer KV por _id eficientemente pero tiene m√°s overhead que soluciones especializadas. No √≥ptimo para KV puro.",
                    "PostgreSQL": "Usar SQL para simple KV es como usar un cami√≥n para entregar pizza. Funcionar√° pero es excesivo y no escala.",
                    "Redis": "Millones de ops/seg en memoria. Excepcional para key-value pero limitado por RAM disponible.",
                    "DynamoDB": "Dise√±ada espec√≠ficamente para esto. Escalabilidad casi ilimitada con latencia consistente de un d√≠gito ms.",
                    "Google BigQuery": "No dise√±ado para buscar registros individuales por clave. Requiere escanear, muy ineficiente.",
                    "Google Firestore": "Puede manejar KV pero m√°s costoso que alternativas especializadas. Mejor para queries m√°s complejas.",
                    "Google Bigtable": "Hecha para alto throughput key-value. Escala linealmente agregando nodos, millones ops/seg posibles.",
                    "Google AlloyDB": "Base relacional compleja. Demasiado overhead para simples operaciones KV. No es el caso de uso.",
                    "YugabyteDB": "YCQL (API Cassandra) excelente para key-value distribuido. Escala horizontalmente para KV masivo."
                }
            },
            {
                question: "¬øBI interactivo o ML con SQL?",
                explanations: {
                    "MongoDB": "Se integra con herramientas BI v√≠a conectores pero no ejecuta ML nativamente. MongoDB Charts para visualizaci√≥n b√°sica.",
                    "PostgreSQL": "Fuente para BI pero no optimizado para escaneo masivo anal√≠tico. ML requiere extensiones externas como MADlib.",
                    "Redis": "No es herramienta anal√≠tica ni de BI. Es un cache operacional, no para an√°lisis de datos.",
                    "DynamoDB": "No es base anal√≠tica. Los datos deben exportarse a S3 y analizarse con Athena o replicarse a Redshift.",
                    "Google BigQuery": "Dise√±ado espec√≠ficamente para esto. BigQuery ML permite crear y ejecutar modelos (regresi√≥n, clustering, etc.) con SQL puro.",
                    "Google Firestore": "Base operacional para aplicaciones. Se exporta a BigQuery para cualquier an√°lisis o BI.",
                    "Google Bigtable": "Almac√©n para servir datos a baja latencia, no para consultas BI complejas. Requiere herramientas externas.",
                    "Google AlloyDB": "A pesar del motor columnar secundario, no tiene ML integrado ni est√° optimizado para BI masivo como BigQuery.",
                    "YugabyteDB": "Base transaccional distribuida OLTP. No dise√±ada para cargas BI masivas ni tiene capacidades ML."
                }
            },
            {
                question: "¬øSincronizaci√≥n tiempo real con clientes y offline?",
                explanations: {
                    "MongoDB": "Posible con Change Streams y Atlas Device Sync pero requiere configuraci√≥n adicional. No tan integrado como Firestore.",
                    "PostgreSQL": "Requiere arquitectura compleja adicional con LISTEN/NOTIFY + websockets + cache cliente. No es nativo.",
                    "Redis": "PUB/SUB puede ser componente de arquitectura real-time pero no ofrece sincronizaci√≥n de estado ni soporte offline.",
                    "DynamoDB": "Posible con DynamoDB Streams + AWS AppSync pero es arquitectura m√°s compleja, no caracter√≠stica nativa.",
                    "Google BigQuery": "Base anal√≠tica batch, no para aplicaciones en tiempo real. No tiene concepto de listeners.",
                    "Google Firestore": "Raz√≥n de ser principal. SDKs con listeners autom√°ticos, actualizaciones real-time y cach√© offline robusto integrado.",
                    "Google Bigtable": "No dise√±ada para sincronizaci√≥n con clientes finales. Es backend para servir datos, no para apps real-time.",
                    "Google AlloyDB": "Base relacional tradicional sin capacidades de sincronizaci√≥n real-time o SDKs para clientes.",
                    "YugabyteDB": "Sin mecanismo nativo para sincronizaci√≥n con clientes. Requerir√≠a arquitectura adicional compleja."
                }
            },
            {
                question: "¬øRendimiento OLTP superior con compatibilidad PostgreSQL?",
                explanations: {
                    "MongoDB": "Alto rendimiento OLTP pero no es compatible con PostgreSQL. Usa su propio lenguaje de consultas.",
                    "PostgreSQL": "Es la l√≠nea base de rendimiento. No puede ser superior a s√≠ mismo. Escalado principalmente vertical.",
                    "Redis": "No es base relacional ni compatible con PostgreSQL. Es un cache key-value.",
                    "DynamoDB": "Alto rendimiento pero no es compatible con PostgreSQL ni SQL. API propietaria.",
                    "Google BigQuery": "No es base OLTP sino OLAP. Para an√°lisis, no transacciones.",
                    "Google Firestore": "No es base relacional SQL. Es NoSQL documental con su propia API.",
                    "Google Bigtable": "No es base relacional. Alta performance pero no compatible con PostgreSQL.",
                    "Google AlloyDB": "Exactamente dise√±ado para esto. PostgreSQL 100% compatible con 4x mejor rendimiento transaccional.",
                    "YugabyteDB": "SQL distribuido que escala OLTP horizontalmente manteniendo compatibilidad PostgreSQL. Performance superior via distribuci√≥n."
                }
            },
            {
                question: "¬øIngesta masiva IoT/Ad-Tech (millones ops/seg)?",
                explanations: {
                    "MongoDB": "Escala bien pero 'millones ops/seg' apunta a h√≠per-escala donde Bigtable/DynamoDB son m√°s naturales.",
                    "PostgreSQL": "Una instancia no puede manejar millones ops/seg. Necesitar√≠a sharding complejo manual.",
                    "Redis": "Muy r√°pido pero limitaci√≥n de memoria hace impr√°ctica la ingesta persistente masiva. Mejor como cache.",
                    "DynamoDB": "Dise√±ada para esto. Maneja millones ops/seg con auto-sharding y latencia consistente. Caso de uso perfecto.",
                    "Google BigQuery": "Streaming ingestion de alto throughput pero para an√°lisis posterior, no para servir lecturas de baja latencia.",
                    "Google Firestore": "L√≠mites de escritura (10k/seg inicialmente) muy por debajo de millones ops/seg. No es para este caso.",
                    "Google Bigtable": "Caso de uso can√≥nico. Optimizada espec√≠ficamente para ingesta masiva IoT/Ad-Tech con baja latencia a escala planetaria.",
                    "Google AlloyDB": "Base relacional no dise√±ada para ingesta NoSQL masiva. Mejor para transacciones ACID complejas.",
                    "YugabyteDB": "Arquitectura distribuida permite escalar ingesta horizontalmente. Buena opci√≥n para IoT con requerimientos ACID."
                }
            }
        ];

        const recommendations = {
            'MongoDB': 'Ideal para aplicaciones modernas con modelos de datos flexibles, consultas complejas y alta disponibilidad multi-regi√≥n. Excelente balance entre funcionalidad y facilidad de uso.',
            'PostgreSQL': 'Excelente para aplicaciones que requieren consultas relacionales complejas, transacciones ACID robustas y funcionalidades geoespaciales con PostGIS.',
            'DynamoDB': 'Perfecto para aplicaciones serverless, operaciones key-value masivas y casos de uso con patrones de acceso predecibles. Escalabilidad pr√°cticamente ilimitada.',
            'Redis': 'Perfecto para cach√© en memoria, operaciones key-value de ultra baja latencia y casos de uso de alta velocidad. Ideal como complemento a otras bases de datos.',
            'Google BigQuery': '√ìptimo para an√°lisis de datos masivos, data warehousing y Business Intelligence. √önico en su capacidad de ejecutar ML con SQL (BigQuery ML).',
            'Google Firestore': 'Ideal para aplicaciones web/m√≥viles que necesitan sincronizaci√≥n en tiempo real, soporte offline y escalado autom√°tico sin gesti√≥n de infraestructura.',
            'Google Bigtable': 'Excelente para ingesta masiva de datos IoT, Ad-Tech y series de tiempo. Maneja millones de operaciones por segundo con latencia consistente.',
            'Google AlloyDB': 'Perfecto cuando necesitas rendimiento PostgreSQL mejorado significativamente. Combina compatibilidad total con optimizaciones de Google.',
            'YugabyteDB': 'Ideal para aplicaciones que necesitan SQL distribuido globalmente con consistencia fuerte. Combina escalabilidad NoSQL con garant√≠as ACID.'
        };

        let currentAnswers = [];
        let currentQuestionIndex = 0;

        function initializeMatrix() {
            createProgressIndicator();
            updateLiveResults();
            showQuestion(0);
        }

        function createProgressIndicator() {
            const container = document.getElementById('progressIndicator');
            container.innerHTML = '';
            
            for (let i = 0; i < questions.length; i++) {
                const dot = document.createElement('div');
                dot.className = 'progress-dot';
                if (i === 0) dot.classList.add('current');
                container.appendChild(dot);
            }
        }

        function updateProgressIndicator() {
            const dots = document.querySelectorAll('.progress-dot');
            dots.forEach((dot, index) => {
                dot.className = 'progress-dot';
                if (index < currentQuestionIndex) {
                    dot.classList.add('completed');
                } else if (index === currentQuestionIndex) {
                    dot.classList.add('current');
                }
            });
        }

        function showQuestion(index) {
            if (index >= questions.length) {
                const container = document.getElementById('questionsContainer');
                container.innerHTML = `
                    <div class="card question-card animate-fadeIn" style="text-align: center; background: linear-gradient(135deg, var(--color-primary-light) 0%, rgba(86, 68, 212, 0.1) 100%); border: 2px solid var(--color-primary);">
                        <h3 style="color: var(--color-primary); margin-bottom: var(--spacing-md);">
                            üéâ ¬°Evaluaci√≥n Completada!
                        </h3>
                        <p style="color: var(--color-text-secondary); font-size: var(--text-lg);">
                            Has respondido todas las preguntas. Revisa los resultados finales y la recomendaci√≥n abajo.
                        </p>
                    </div>
                `;
                document.getElementById('resetButtonContainer').style.display = 'block';
                document.querySelector('#resultsSection h2').innerHTML = 'üéØ An√°lisis Completado - Resultados Finales';
                return;
            }

            const container = document.getElementById('questionsContainer');
            container.innerHTML = `
                <div class="card question-card animate-fadeIn">
                    <div class="badge badge-secondary mb-3">
                        Pregunta ${index + 1} de ${questions.length}
                    </div>
                    <div class="question-text">
                        ${questions[index]}
                    </div>
                    <div class="response-buttons">
                        <button class="response-btn" onclick="answerQuestion(true, ${index})">
                            ‚úÖ S√≠
                        </button>
                        <button class="response-btn" onclick="answerQuestion(false, ${index})">
                            ‚ùå No
                        </button>
                    </div>
                </div>
            `;

            if (currentAnswers[index] !== undefined) {
                const buttons = container.querySelectorAll('.response-btn');
                if (currentAnswers[index]) {
                    buttons[0].classList.add('selected');
                } else {
                    buttons[1].classList.add('selected');
                }
            }
        }

        function answerQuestion(answer, index) {
            currentAnswers[index] = answer;
            
            const buttons = document.querySelectorAll('.response-btn');
            buttons.forEach(btn => btn.classList.remove('selected'));
            if (answer) {
                buttons[0].classList.add('selected');
            } else {
                buttons[1].classList.add('selected');
            }

            updateLiveResults();

            setTimeout(() => {
                currentQuestionIndex = index + 1;
                updateProgressIndicator();
                showQuestion(currentQuestionIndex);
            }, 500);
        }

        function updateLiveResults() {
            const scores = calculateScores();
            const maxScore = Math.max(...Object.values(scores));
            const winner = Object.keys(scores).find(db => scores[db] === maxScore);

            displayScores(scores, maxScore);
            
            const answeredQuestions = currentAnswers.filter(a => a !== undefined).length;
            if (answeredQuestions > 0) {
                displayRecommendation(winner, maxScore);
            } else {
                const container = document.getElementById('recommendationContainer');
                container.innerHTML = `
                    <div class="recommendation animate-fadeIn">
                        <h3>üîÆ Predicci√≥n en Progreso</h3>
                        <p style="color: var(--color-text-secondary); font-size: var(--text-lg); text-align: center;">
                            Responde las preguntas para ver tu recomendaci√≥n personalizada
                        </p>
                        <div class="badge badge-secondary mt-3">
                            Progreso: 0/${questions.length} preguntas
                        </div>
                    </div>
                `;
            }
        }

        function calculateScores() {
            const scores = {};
            
            Object.keys(databases).forEach(dbName => {
                let score = 0;
                const dbAnswers = databases[dbName];
                
                for (let i = 0; i < currentAnswers.length; i++) {
                    if (currentAnswers[i] !== undefined) {
                        if (currentAnswers[i] === true && dbAnswers[i] === 1) {
                            score++;
                        } else if (currentAnswers[i] === false && dbAnswers[i] === 0) {
                            score++;
                        }
                    }
                }
                
                scores[dbName] = score;
            });
            
            return scores;
        }

        function getDBTypeBadge(dbName) {
            if (dbName === 'MongoDB') return '<span class="database-type-badge badge-mongodb">NoSQL Leader</span>';
            if (dbName.includes('Google')) return '<span class="database-type-badge badge-google">Google Cloud</span>';
            if (dbName === 'DynamoDB') return '<span class="database-type-badge badge-aws">AWS</span>';
            if (dbName === 'PostgreSQL' || dbName === 'Redis' || dbName === 'YugabyteDB') 
                return '<span class="database-type-badge badge-opensource">Open Source</span>';
            return '';
        }

        function displayScores(scores, maxScore) {
            const container = document.getElementById('scoresContainer');
            container.innerHTML = '';

            const answeredQuestions = currentAnswers.filter(a => a !== undefined).length;
            const totalQuestions = questions.length;

            const sortedDatabases = Object.entries(scores)
                .sort(([,a], [,b]) => b - a);

            sortedDatabases.forEach(([dbName, score], index) => {
                const percentage = answeredQuestions > 0 ? (score / answeredQuestions) * 100 : 0;
                const isWinner = score === maxScore && answeredQuestions > 0 && score > 0;
                
                const scoreDiv = document.createElement('div');
                scoreDiv.className = `database-score animate-slideInLeft`;
                scoreDiv.style.animationDelay = `${index * 0.1}s`;
                
                scoreDiv.innerHTML = `
                    <div class="database-name ${isWinner ? 'text-gradient' : ''}">
                        ${isWinner ? 'üèÜ ' : ''}${dbName}
                        ${getDBTypeBadge(dbName)}
                    </div>
                    <div class="score-container">
                        <div class="score-bar">
                            <div class="score-fill" style="width: ${percentage}%"></div>
                        </div>
                        <div class="score-value">${score}/${answeredQuestions || totalQuestions}</div>
                    </div>
                `;
                
                container.appendChild(scoreDiv);
            });
        }

        function displayRecommendation(winner, maxScore) {
            const container = document.getElementById('recommendationContainer');
            const answeredQuestions = currentAnswers.filter(a => a !== undefined).length;
            const percentage = answeredQuestions > 0 ? Math.round((maxScore / answeredQuestions) * 100) : 0;
            
            const isComplete = answeredQuestions === questions.length;
            const title = isComplete ? 'üéØ Recomendaci√≥n Final' : 'üîÆ Recomendaci√≥n Actual';

            if (maxScore > 0) {
                container.innerHTML = `
                    <div class="recommendation animate-fadeIn">
                        <h3>${title}</h3>
                        <div class="database-name" style="font-size: var(--text-3xl); margin-bottom: var(--spacing-md);">
                            ${winner} ${getDBTypeBadge(winner)}
                        </div>
                        <div class="metric-value" style="margin-bottom: var(--spacing-md); color: var(--color-primary); font-size: var(--text-2xl); font-weight: 700;">
                            ${percentage}% de compatibilidad
                        </div>
                        <p style="color: var(--color-text-secondary); font-size: var(--text-lg);">
                            ${recommendations[winner]}
                        </p>
                        ${!isComplete ? `
                            <div class="badge badge-secondary mt-3">
                                Progreso: ${answeredQuestions}/${questions.length} preguntas
                            </div>
                        ` : ''}
                    </div>
                `;
            }
        }

        function resetMatrix() {
            currentAnswers = [];
            currentQuestionIndex = 0;
            document.getElementById('questionsContainer').style.display = 'block';
            document.getElementById('progressIndicator').style.display = 'flex';
            document.getElementById('resetButtonContainer').style.display = 'none';
            document.getElementById('technicalJustification').style.display = 'none';
            document.querySelector('#resultsSection h2').innerHTML = 'üìä Resultados en Tiempo Real';
            initializeMatrix();
        }

        function toggleJustification() {
            const justificationSection = document.getElementById('technicalJustification');
            const btn = document.getElementById('justificationBtn');
            
            if (justificationSection.style.display === 'none') {
                generateJustificationContent();
                justificationSection.style.display = 'block';
                btn.innerHTML = 'üìã Ocultar Justificaci√≥n T√©cnica';
                justificationSection.scrollIntoView({ behavior: 'smooth' });
            } else {
                justificationSection.style.display = 'none';
                btn.innerHTML = 'üìã Ver Justificaci√≥n T√©cnica Detallada';
            }
        }

        function generateJustificationContent() {
            const container = document.getElementById('justificationContent');
            container.innerHTML = '';

            technicalJustifications.forEach((justification, index) => {
                if (currentAnswers[index] !== undefined) {
                    const userAnswer = currentAnswers[index];
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'justification-question animate-fadeIn';
                    questionDiv.style.animationDelay = `${index * 0.05}s`;

                    const scores = {};
                    Object.keys(databases).forEach(dbName => {
                        scores[dbName] = databases[dbName][index];
                    });

                    questionDiv.innerHTML = `
                        <div class="question-title">
                            <span>‚ùì</span>
                            ${justification.question}
                            <span class="user-response ${userAnswer ? 'yes' : 'no'}">
                                ${userAnswer ? '‚úÖ S√≠' : '‚ùå No'}
                            </span>
                        </div>
                        <div class="justification-content">
                            <div style="margin-bottom: var(--spacing-md);">
                                <strong>Puntuaciones por tecnolog√≠a:</strong>
                                ${Object.entries(scores).map(([db, score]) => 
                                    `<span class="tech-score score-${score}">
                                        ${db}: ${score === 1 ? '‚úì' : '‚úó'}
                                    </span>`
                                ).join('')}
                            </div>
                            <div class="tech-explanation">
                                <strong style="color: var(--color-primary);">An√°lisis Arquitect√≥nico:</strong><br><br>
                                ${Object.entries(justification.explanations).map(([db, explanation]) => {
                                    const score = scores[db];
                                    const matches = (userAnswer && score === 1) || (!userAnswer && score === 0);
                                    return `<div style="margin-bottom: var(--spacing-sm); padding: 8px; border-radius: 4px; ${matches ? 'background: rgba(0, 237, 100, 0.05);' : 'background: rgba(239, 68, 68, 0.05);'}">
                                        <strong>${db}</strong> 
                                        <span class="tech-score score-${score}">${score === 1 ? 'S√≠' : 'No'}</span>
                                        ${matches ? '<span style="color: var(--color-primary); font-weight: bold;">‚úì Match</span>' : '<span style="color: #EF4444; font-weight: bold;">‚úó No Match</span>'}
                                        <br>
                                        <span style="color: var(--color-text-secondary);">${explanation}</span>
                                    </div>`;
                                }).join('')}
                            </div>
                        </div>
                    `;

                    container.appendChild(questionDiv);
                }
            });

            // Agregar resumen al final
            const summary = document.createElement('div');
            summary.className = 'recommendation animate-fadeIn';
            summary.style.marginTop = 'var(--spacing-xl)';
            
            const scores = calculateScores();
            const sortedDatabases = Object.entries(scores).sort(([,a], [,b]) => b - a);
            
            summary.innerHTML = `
                <h3 style="color: var(--color-primary);">üìà Resumen de Compatibilidad</h3>
                <p style="margin-bottom: var(--spacing-lg);">Basado en tus ${currentAnswers.filter(a => a !== undefined).length} respuestas:</p>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: var(--spacing-md);">
                    ${sortedDatabases.map(([db, score], index) => {
                        const percentage = Math.round((score / currentAnswers.filter(a => a !== undefined).length) * 100);
                        const isTop = index === 0;
                        return `
                            <div style="padding: var(--spacing-md); background: ${isTop ? 'rgba(0, 237, 100, 0.1)' : 'rgba(255, 255, 255, 0.05)'}; border-radius: var(--radius-md); border: 1px solid ${isTop ? 'var(--color-primary)' : 'rgba(255, 255, 255, 0.1)'};">
                                <div style="font-weight: 700; margin-bottom: var(--spacing-xs);">
                                    ${isTop ? 'üèÜ ' : ''}${db}
                                </div>
                                <div style="font-size: var(--text-2xl); color: ${isTop ? 'var(--color-primary)' : 'var(--color-text-secondary)'};">
                                    ${percentage}%
                                </div>
                                <div style="font-size: var(--text-sm); color: var(--color-text-secondary);">
                                    ${score}/${currentAnswers.filter(a => a !== undefined).length} coincidencias
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            
            container.appendChild(summary);
        }

        // Inicializar la matriz al cargar la p√°gina
        document.addEventListener('DOMContentLoaded', initializeMatrix);
    </script>
</body>
</html>